\section{Min-Weight Perfect Bipartite Matching} \label{chp:min_weight_perfect_bipartite_matching}

\subsection{Introduction and Motivation}
The fundamental goal of our compression scheme is to transform an input trie into a compressed, $p$-sortable automaton by partitioning its nodes into $p$ chains in an optimal way.

To make this optimization problem more concrete, we can frame it as a string partitioning problem. Imagine the sequence of nodes in the trie, when read in co-lexicographic order, as a single long string. The "character" corresponding to each node is its Myhill-Nerode equivalence class, which determines if it can be merged with other nodes. The task is to partition this string of nodes into $p$ subsequences such that the number of runs is minimized (consecutive nodes of the same equivalence class are merged into a single "run"). For instance, a subsequence $AAABBA$ contains three runs. Minimizing the number of runs directly corresponds to maximizing the number of merged states, yielding a compact $p$-sortable automaton.

In this sections, we will provide the necessary background on the Minimum Weight Perfect Bipartite Matching (MWPBM) problem, a fundamental challenge in combinatorial optimization. We will then demonstrate in \cref{chp:tree_compression} a formal reduction from our partitioning problem to MWPBM. This reduction is the key to our method, as it allows us to model our problem as a bipartite graph and leverage well-known, efficient algorithms to find the optimal solution for our compression task.

\subsection{Bipartite Graphs} 
\begin{definition} \label{def:bipartite}
    A graph $G=(V,E)$ is called \textit{bipartite} if its vertex set $V$ can be partitioned into two disjoint subsets $V=V_1 \cup V_2$ such that every edge in $E$ has the form $(v_1,v_2)$ where $v_1\in V_1$ and $v_2 \in V_2$.
\end{definition} 

In other words, the vertices of the graph can be divided into two separate groups such that all edges connect a vertex from the first group to a vertex from the second group. An example of a bipartite graph is shown in \cref{fig:bipartite_graph_example}.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance={15mm}, thick, auto=center, main/.style = {draw, circle}] 
        \node[main] (2s) {$x_1$}; 
        \node[main] (1s) [below of=2s] {$x_2$};
        \node[main] (4s) [below of=1s] {$x_3$};
        \node[main] (3d) [right=2cm of 2s] {$x_4$};
        \node[main] (2d) [below of=3d] {$x_5$}; 
        \node[main] (1d) [below of=2d] {$x_6$};
        \node[main] (4d) [below of=1d] {$x_7$};
        \draw[->] (1s) -- (3d);
        \draw[->] (1s) -- (2d);
        \draw[->] (4s) -- (3d);
        \draw[->] (2s) -- (4d);
        \draw[->] (4s) -- (4d);
        \draw[->] (2s) -- (1d);
    \end{tikzpicture}     
    \caption[Example of a bipartite graph]{Example of a bipartite graph $G=(V, E)$ where $V_1=\{x_1,x_2,x_3\}$, $V_2=\{x_4,x_5,x_6,x_7\}$ and $E=\{(x_1,x_6),(x_1,x_7),(x_2,x_4),(x_2,x_5),(x_3,x_4),(x_3,x_7)\}$.}
    \label{fig:bipartite_graph_example}
\end{figure}

\begin{definition}[Weighted Bipartite Graph] \label{def:weighted_bipartite}
    A \textit{weighted bipartite graph} is a bipartite graph $G=(V, E, w)$, where $w$ is a weight function $w: E \to \mathbb{R}$ that assigns a real-valued weight to each edge.
\end{definition}

In a weighted bipartite graph, each edge has a numerical value, or "weight", associated with it.

\subsection{Problem Definition}
Given a bipartite graph $G = (V, E)$ (\cref{def:bipartite}), let's define the concept of a matching. 

\begin{definition}[Matching] \label{def:matching}
    Given a bipartite graph $G = (V, E)$, a matching $M \subseteq E$ is a collection of edges such that every vertex of $V$ is incident to at most one edge of $M$.
\end{definition}

In other words, a matching is a set of edges such that no two edges share a common vertex. If a vertex $v$ has no edge of $M$ incident to it, then $v$ is said to be exposed (or unmatched). A matching is \textbf{perfect} if no vertex is exposed; in other words, a matching is perfect if its cardinality is equal to $|V_1| = |V_2|$ \cite{goemans2009matching}.

\begin{example}
    In \cref{fig:matching_examples_style2}, we illustrate three distinct scenarios. Subfigure (a) depicts a set of edges that does not constitute a valid matching, as vertex $u_1$ is incident to more than one edge, namely $(u_1, v_1)$ and $(u_1, v_2)$, violating the definition of a matching. Subfigure (b) presents a valid, yet non-perfect matching; here, vertices $u_3$ and $v_3$ are exposed, meaning they are not incident to any edge in the matching. Finally, subfigure (c) shows a perfect matching, where every vertex in the graph is incident to exactly one edge in the matching, satisfying the condition $|M| = |V_1| = |V_2| = 3$.
    \begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \begin{tikzpicture}[node distance={15mm}, thick, auto=center, main/.style = {draw, circle}]
                \node[main] (u1) {$u_1$};
                \node[main] (u2) [below of=u1] {$u_2$};
                \node[main] (u3) [below of=u2] {$u_3$};
                \node[main] (v1) [right=2cm of u1] {$v_1$};
                \node[main] (v2) [below of=v1] {$v_2$};
                \node[main] (v3) [below of=v2] {$v_3$};
                \draw[->] (u1) -- (v1);
                \draw[->] (u1) -- (v2);
                \draw[->] (u2) -- (v2);
                \draw[->] (u3) -- (v3);
                \draw[->, red] (u1) -- (v1);
                \draw[->, red] (u1) -- (v2);
            \end{tikzpicture}
            \caption{Not a matching}
            \label{fig:not_a_matching_style2}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \begin{tikzpicture}[node distance={15mm}, thick, auto=center, main/.style = {draw, circle}]
                \node[main] (u1) {$u_1$};
                \node[main] (u2) [below of=u1] {$u_2$};
                \node[main] (u3) [below of=u2] {$u_3$};
                \node[main] (v1) [right=2cm of u1] {$v_1$};
                \node[main] (v2) [below of=v1] {$v_2$};
                \node[main] (v3) [below of=v2] {$v_3$};
                \draw[->] (u1) -- (v1);
                \draw[->] (u1) -- (v2);
                \draw[->] (u2) -- (v2);
                \draw[->] (u3) -- (v3);
                \draw[->, red] (u1) -- (v1);
                \draw[->, red] (u2) -- (v2);
            \end{tikzpicture}
            \caption{A non-perfect matching}
            \label{fig:non_perfect_matching_style2}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \begin{tikzpicture}[node distance={15mm}, thick, auto=center, main/.style = {draw, circle}]
                \node[main] (u1) {$u_1$};
                \node[main] (u2) [below of=u1] {$u_2$};
                \node[main] (u3) [below of=u2] {$u_3$};
                \node[main] (v1) [right=2cm of u1] {$v_1$};
                \node[main] (v2) [below of=v1] {$v_2$};
                \node[main] (v3) [below of=v2] {$v_3$};
                \draw[->] (u1) -- (v1);
                \draw[->] (u1) -- (v2);
                \draw[->] (u2) -- (v2);
                \draw[->] (u3) -- (v3);
                \draw[->, red] (u1) -- (v1);
                \draw[->, red] (u2) -- (v2);
                \draw[->, red] (u3) -- (v3);
            \end{tikzpicture}
            \caption{A perfect matching}
            \label{fig:perfect_matching_style2}
        \end{subfigure}
        \caption{Examples of a non-matching (a), a non-perfect matching (b), and a perfect matching (c) in a bipartite graph. The edges in the set $M$ are highlighted in red.}
        \label{fig:matching_examples_style2}
    \end{figure}
\end{example}

The problem of finding a minimum weight perfect matching in a weighted bipartite graph (\cref{def:weighted_bipartite}) is a well-known problem in combinatorial optimization. The problem can be formulated as follows: 

\begin{definition}[Minimum weight perfect matching in weighted bipartite graphs] \label{def:mwpbm}
    Given a weighted bipartite graph $G = (V, E, w)$, find a perfect matching $M$ such that the sum of the weights of the edges in $M$ is minimized.
\end{definition}

The weight of a matching is the sum of the weights of the edges in the matching. We define the weight of a matching $M$ as follows:
\begin{equation}
    w(M) = \sum_{e \in M} w(e)
\end{equation}

\begin{example}
    Consider the weighted bipartite graph in \cref{fig:mwpbm_example}. The goal is to find a perfect matching with the minimum possible total weight. Both subfigures show a valid perfect matching; however, only one of them has the minimum weight.
    \begin{itemize}
        \item Subfigure (a) shows the perfect matching $M_a = \{(u_1, v_2), (u_2, v_1), (u_3, v_3)\}$. Its total weight is $w(M_a) = w(u_1, v_2) + w(u_2, v_1) + w(u_3, v_3) = 2 + 1 + 1 = 4$. This is a valid perfect matching, but it is not optimal.
        \item Subfigure (b) shows the perfect matching $M_b = \{(u_1, v_1), (u_2, v_2), (u_3, v_3)\}$. Its total weight is $w(M_b) = w(u_1, v_1) + w(u_2, v_2) + w(u_3, v_3) = 1 + 1 + 1 = 3$.
    \end{itemize}
    Since $w(M_b) < w(M_a)$, the matching in (b) is a minimum weight perfect matching for this graph, while the matching in (a) is a non-minimum perfect matching.
    \begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{tikzpicture}[node distance={15mm}, thick, auto=center, main/.style = {draw, circle}]
                \node[main] (u1) {$u_1$};
                \node[main] (u2) [below of=u1] {$u_2$};
                \node[main] (u3) [below of=u2] {$u_3$};
                \node[main] (v1) [right=2cm of u1] {$v_1$};
                \node[main] (v2) [below of=v1] {$v_2$};
                \node[main] (v3) [below of=v2] {$v_3$};
                \draw[->] (u1) -- (v1);
                \draw[->, dashed] (u1) -- (v2);
                \draw[->] (u2) -- (v1);
                \draw[->] (u2) -- (v2); 
                \draw[->] (u3) -- (v3); 
                \draw[->, dashed, red] (u1) -- (v2);
                \draw[->, red] (u2) -- (v1);
                \draw[->, red] (u3) -- (v3);
            \end{tikzpicture}
            \caption{A non-minimum perfect matching.}
            \label{fig:mwpbm_non_perfect}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{tikzpicture}[node distance={15mm}, thick, auto=center, main/.style = {draw, circle}]
                \node[main] (u1) {$u_1$};
                \node[main] (u2) [below of=u1] {$u_2$};
                \node[main] (u3) [below of=u2] {$u_3$};
                \node[main] (v1) [right=2cm of u1] {$v_1$};
                \node[main] (v2) [below of=v1] {$v_2$};
                \node[main] (v3) [below of=v2] {$v_3$};
                \draw[->] (u1) -- (v1);
                \draw[->, dashed] (u1) -- (v2);
                \draw[->] (u2) -- (v1);
                \draw[->] (u2) -- (v2); 
                \draw[->] (u3) -- (v3); 
                \draw[->, red] (u1) -- (v1);
                \draw[->, red] (u2) -- (v2);
                \draw[->, red] (u3) -- (v3);
            \end{tikzpicture}
            \caption{A minimum perfect matching.}
            \label{fig:mwpbm_perfect}
        \end{subfigure}
        \caption{Example of a non-minimum perfect matching (a) and minimum perfect matching (b) in a weighted bipartite graph. Dashed edges have weight 2 while solid edges 1. The edges in a matching are highlighted in red.}
        \label{fig:mwpbm_example}
    \end{figure}
\end{example}

% \alessio{La parte sui pesi si può spiegare fuori dalla definizione, dato che non è relativa al problema ma al grafo. Occhio che qua usi $e$ per indicare un arco, ma prima usavi $e$ per indicare il numero di archi in un grafo. $e$ ci sta meglio qua a mio parere, prima scegli se usare $m$ (se è un simbolo libero) o direttamente $|E|$}

\begin{comment}
\subsection{The existence of perfect matchings in bipartite graphs}
In this section, we introduce two theorems that state a condition for the existence of perfect matchings in bipartite graphs. These theorems will be useful in the following chapter to prove our reduction \cite{viswanath2004perfect}. \alessio{Specifica se la condizione è sufficiente e/o necessaria}
\subsection{The Tutte matrix and its determinant}

Let's start with the definition of the \textbf{Tutte matrix} of a bipartite graph.
\begin{definition}[Tutte matrix] \label{def:tutte_matrix}
    The Tutte matrix of bipartite graph $G = (U, V, E)$ is an $n \times n$ matrix $M$ with the entry at row $i$ and column $j$
    \begin{equation}
        M_{i,j} =
        \begin{cases}
            0 & \text{if } (u_i, u_j) \notin E \\
            x_{i,j} & \text{if } (u_i, u_j) \in E
        \end{cases}
    \end{equation}
    \alessio{Cos'é $U$ nella definizione del grafo? Prima hai usato $V_1$ e $V_2$ per le due componenti, mantieni la stessa notazione (o cambiala prima, ma forse è più bella con i pedici).}
    \alessio{Posta così, $u_i$ e $u_j$ sembrano appartenere solo a $U$. In ogni caso, la Tutte matrix si può calcolare per un qualsiasi grafo, quindi lascerei la definizione generica. Altrimenti se vuoi stare sul grafo bipartito, bisognerebbe usare la Edmonds matrix (e in quel caso usare $U$ e $V$)}
    \alessio{Dovresti specificare che i vari $x_{i,j}$ sono ``indeterminates''}

\end{definition}

The determinant of the Tutte matrix is useful in testing whether a graph has a perfect matching or not, as the following theorem introduced in \cite{lovasz1979matching} shows. 

\begin{theorem}[Existence of perfect matchings in bipartite graphs \cite{lovasz1979matching}] \label {thm:perfect_matching_existence}
    Given a bipartite graph $G$ and the Tutte matrix $M$ for $G$ then the following equivalence holds:
    $$
    Det(M) \neq 0 \iff \text{There exists a perfect matching in G}
    $$
\end{theorem}

\begin{proof}
    We have the following expression for the determinant, \draft{also called Leibniz formula}:

    $$
    \text{Det}(M) = \sum_{\pi \in S_n} (-1)^{sgn(\pi)} \prod_{i=1}^{n} M_{i,\pi(i)}
    $$
    \alessio{Cosa ritorna sgn? 0 o 1? In caso puoi fargli ritornare -1 e 1 e non ti serve l'esponente.}

    where $S_n$ is the set of all permutations on $[n]$, and $sgn(\pi)$ is the sign of the permutation $\pi$. \alessio{Definisci il segno di una permutazione. Prima indicavi le permutazioni con $\Pi$, ora con $\pi$. Immagino che sia per la moltiplicatoria, valuta se usare $\pi$ anche prima.}
    There is a one-to-one correspondence between a permutation $\pi \in S_n$ and a (possible) perfect matching 

    $$
    \{(u_1, v_{\pi(1)}), (u_2, v_{\pi(2)}), \cdots , (u_n, v_{\pi(n)})\} \text{ in } G.
    $$

    Note that if this perfect matching does not exist in $G$ (i.e., some edge $(u_i, v_{\pi(i)}) \notin E$), then the term corresponding to $\pi$ in the summation is $0$. So we have

    $$
    \text{Det}(M) = \sum_{\pi \in P} (-1)^{sgn(\pi)} \prod_{i=1}^{n} x_{i,\pi(i)}
    $$

    where $P$ is the set of perfect matchings in $G$. This is zero if $P = \emptyset$, i.e., if $G$ has no perfect matching. If $G$ has a perfect matching, there is \draft{at least} a $\pi \in P$ and the term corresponding to $\pi$ is

    $$
    \prod_{i=1}^{n} x_{i,\pi(i)} \neq 0.
    $$

    Additionally, there is no other term in the summation that contains the same set of variables. Therefore, this term is not cancelled by any other term. So in this case, $\text{Det}(M) \neq 0$.
\end{proof}
\end{comment}

\subsection{Hall's Marriage Theorem}
Hall's Marriage Theorem \cite{hall1935representatives} provides a necessary and sufficient condition for the existence of a matching that saturates an entire partition of a bipartite graph. Specifically, it allows us to determine if there is a matching that includes every vertex from the smaller of the two partitions. In the special case where the partitions are of equal size ($|V_1| = |V_2|$), the theorem gives a condition for the existence of a perfect matching.

% TODO: sistemare
This theorem will be crucial in proving the correctness of our reduction from the tree partitioning problem to the minimum weight perfect bipartite matching problem. Specifically, we will use it to show that our constructed bipartite graph always admits a perfect matching, ensuring that our reduction is valid.
    
\begin{definition}[Neighborhood] \label{def:neighborhood}
For a subset of vertices $W \subseteq V_1$, the \textbf{neighborhood} of $W$, denoted by $N(W)$, is the subset of all vertices in $V_2$ that are adjacent to at least one vertex in $W$.
\[ N(W) = \{ v \in V_2 \mid \exists u \in W \text{ $\land$ } \{u, v\} \in E \} \]
\end{definition}

\begin{theorem}[Hall's Marriage Theorem \cite{hall1935representatives}] \label{thm:halls_marriage_theorem}
    Let $G = (V, E)$ be a bipartite graph with $V = V_1 \cup V_2$. There exists a matching $M$ in $G$ that covers $V_1$ if and only if for every subset $W \subseteq V_1$, the following condition holds:
    $$|N(W)| \geq |W|$$
\end{theorem}

This condition is known as \textbf{Hall's condition}.

In simpler terms, a matching that covers all vertices in $V_1$ exists if and only if every group of vertices chosen from $V_1$ collectively has at least as many neighbors in $V_2$ as there are vertices in the chosen group.

\begin{comment}
\subsection{Problem Formulation}
The problem of finding a minimum weight perfect matching in a bipartite graph can be formulated as an integer linear program (ILP), i.e., an optimization problem in which the variables are restricted to integer values, and the constraints and the objective function are linear as a function of these variables. Given a matching $M$, let $x$ be its incidence vector where $x_{ij} = 1$ if edge $(i, j)$ is in the matching, and $x_{ij} = 0$ otherwise. Then, the problem can be formulated as follows:

\begin{equation}
    \begin{aligned}
        \text{minimize} \quad & \sum_{(i, j) \in E} w_{ij} x_{ij} \\
        \text{subject to} \quad & \sum_{j \in V_2} x_{ij} = 1, \quad \forall i \in V_1 \\
        & \sum_{i \in V_1} x_{ij} = 1, \quad \forall j \in V_2 \\
        & x_{ij} \in \{0, 1\}, \quad \forall (i, j) \in E
    \end{aligned}
\end{equation}

Notice that any solution to this integer program corresponds to a matching and therefore this is a valid formulation of the minimum weight perfect matching problem in bipartite graphs.

The linear program relaxation $P$ of the above integer program is as follows:

\begin{equation}
    \begin{aligned}
        \text{minimize} \quad & \sum_{(i, j) \in E} w_{ij} x_{ij} \\
        \text{subject to} \quad & \sum_{j \in V_2} x_{ij} = 1, \quad \forall i \in V_1 \\
        & \sum_{i \in V_1} x_{ij} = 1, \quad \forall j \in V_2 \\
        & 0 \leq x_{ij} \leq 1, \quad \forall (i, j) \in E
    \end{aligned}
\end{equation}

The set of feasible solutions to the constraints in P forms a polytope. When optimizing a linear constraint over a polytope, the optimum will be achieved at one of the ``corner'' or extreme points of the polytope. An extreme point $x$ of a set $Q$ is an element $x \in Q$ that cannot be expressed as $\lambda y + (1 - \lambda) z$ with $0 < \lambda < 1$, $y, z \in Q$, and $y \neq z$.

In general, even if all the coefficients of the constraint matrix in a linear program are either 0 or 1, the extreme points of a linear program are not guaranteed to all have integral coordinates. This is not surprising since the general integer programming problem is NP-hard, while linear programming is solvable in polynomial time. Consequently, there is no guarantee that the value $Z_{IP}$ of an integer program is equal to the value $Z_{LP}$ of its LP relaxation. However, since the integer program is more constrained than the relaxation, we always have $Z_{IP} \geq Z_{LP}$, implying that $Z_{LP}$ is a lower bound on $Z_{IP}$ for a minimization problem. Moreover, if an optimal solution to a linear programming relaxation is integral, then it must also be an optimal solution to the integer program.

In our problem, the constraint matrix has a special form that leads to the following result: 

\begin{theorem}
    Any extreme point of $P$ is a $0-1$ vector; hence, it is the incidence vector of a perfect matching.
\end{theorem}

Consequently, the polytope

\begin{equation}
    \begin{aligned}
        \{ x: & \sum_{j \in V_2} x_{ij} = 1, \quad \forall i \in V_1, \\
        & \sum_{i \in V_1} x_{ij} = 1, \quad \forall j \in V_2, \\
        & 0 \leq x_{ij} \leq 1, \quad \forall (i, j) \in E \}
    \end{aligned}
\end{equation}

is called the bipartite perfect matching polytope (see Lecture notes by \cite{goemans2009matching}). 
\end{comment}

\subsection{State of the Art} \label{sec:mwpbm_solutions}
There are several algorithms to solve the problem of finding a minimum weight perfect matching in a bipartite graph. The first algorithm to solve this problem was proposed by Kuhn in 1955 \cite{kuhn1955hungarian}. The algorithm is based on the Hungarian method, which is a combinatorial optimization algorithm that solves the MWPBM problem in polynomial time. In the original paper the complexity of the algorithm was $O(n^4)$ where $n$ is the number of nodes in the bipartite graph. Later Dinic and Kronrod \cite{dinic1969algorithm} showed that the algorithm can be implemented in $O(n^3)$ time.

The Hungarian method is a powerful algorithm; however, it is not very intuitive and can be difficult to implement. In recent years, several other algorithms have been proposed to solve this problem. In 1970, Edmonds and Karp \cite{edmonds1972theoretical} proposed an algorithm that solves the problem in $O(nm + n^2 \log n)$ time, where $m$ is the number of edges. In 1989 Gabow and Tarjan \cite{gabow1989faster} proposed an algorithm that solves the problem in $O(\sqrt{n}m \log(nW))$ time, where $W$ denote the highest edge weight in the graph; costs are assumed to be integral. The algorithms work by scaling. Lastly, in 2009, Sankowski and Piotr \cite{sankowski2009maximum} introduced a randomized algorithm that solves the problem in $O(Wn^\omega)$ time, where $\omega$ is the exponent of matrix multiplication, and $W$ is the highest edge weight in the graph.

In 2022, Chen, Li, et al. \cite{chen2022maximum} proposed a nearly linear time algorithm for the Minimum Cost Flow (MCF) problem, running in $O(m'^{1+o(1)})$ on a network with $m'$ edges. This is highly relevant as the MWPBM problem can be reduced to MCF. Specifically, an MWPBM instance on a bipartite graph with $n$ vertices and $m$ edges can be transformed into an MCF problem on a network with $m' = n^2 + m$ edges.

\davide{move in experiment chapter (?)}
\subsection{Implementation}
To run experiments for the proposed compression scheme, we used a C++ implementation by Vladimir Kolmogorov of the minimum cost perfect matching algorithm described in \cite{kolmogorovBlossomNewImplementation2009}. The implementation is available at \url{https://pub.ista.ac.at/~vnk/software.html}.

In brief, paper \cite{kolmogorovBlossomNewImplementation2009} presents Blossom~V, a practical implementation of Edmonds’ blossom algorithm for computing minimum-cost perfect matchings in undirected weighted graphs. While the theoretical worst-case bounds for the blossom family have steadily improved since Edmonds’ original $O(n^2m)$ algorithm, Blossom~V is designed for strong empirical performance rather than new asymptotic guarantees. It combines two ingredients that had proven effective separately in prior work: the variable $\delta$ (variable dual updates) strategy popularized by Blossom~IV, and systematic use of priority queues to efficiently select minimum-slack edges.

Blossom~V targets general (not necessarily bipartite) graphs, and thus directly applies to our bipartite instances as a special case. In our experiments we use the publicly available Blossom~V implementation as a black-box solver to compute minimum-cost perfect matchings for the graphs generated by our compression pipeline.
