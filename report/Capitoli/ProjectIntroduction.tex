\chapter{Project Overview} \label{chp:project_overview}
As introduced in the first chapter, the primary goal of this thesis is to develop a novel tree compression scheme that effectively leverages repetitive structures within the input tree. The proposed algorithm is designed to identify and compactly represent these recurring patterns, thereby improving compression performance, particularly for highly repetitive trees. This chapter provides an overview of the proposed compression scheme.

\section{Compression Scheme Pipeline}
Let $ T $ be an ordered tree of arbitrary fan-out, depth, and shape. $ T $ consists of $ n $ internal nodes and $ \ell $ leaves, for a total of $ t = n + \ell $ nodes. Every node of $ T $ is labeled with a symbol drawn from an alphabet $ \Sigma $. We assume that $ \Sigma $ is the set of labels effectively used in the nodes of $T$ and that these labels are encoded with the integers in the range $[1, |\Sigma|]$. Then we define the array $\pi$ where, for each node $u$, $\pi(u)$ is the string obtained by concatenating the labels on the \textbf{upward path} from the parent of $u$ to the root of the tree (the root has an empty $\pi$ component).

The following pipeline is used to compress the tree $T$:
\begin{enumerate}
    \item Initially, the array $\pi$ is computed for $T$ by traversing the tree in a pre-order fashion. Then the nodes are stably sorted by the lexicographic order of their $\pi$ strings. To sort the nodes, the \textbf{Path Sort} algorithm introduced in \cref{sec:pathSort} is used, enabling the sorting of nodes in linear time and $O(t \log t)$ space. This sorting step is the one used in the XBWT transform described in \cref{chp:tree_compression}.
    \item Then, using the \cref{alg:minimization-dawg} for minimizing acyclic deterministic finite automata (ADFAs) described in \cref{sec:revuz}, the nodes are partitioned into equivalence classes where two nodes are equivalent if they have the same subtree rooted at them.
    \item Given a width $p$, the previously sorted nodes are then divided into $p$ chains to minimize the run-length encoding of each chain (considering the equivalence classes). To do so, we reduce this problem --- which we call \emph{Chains-Division problem} --- to the Minimum Perfect Bipartite Matching problem (see \cref{chp:min_weight_perfect_bipartite_matching}), which can be solved in polynomial time as described in Section \cref{sec:mwpbm_solutions}.
    \item Lastly, the resulting deterministic finite automaton (DFA) or non-deterministic finite automaton (NFA) can be indexed using the scheme introduced by Cotumaccio et al. \cite{cotumaccio2023co}. Also, the chains may be compressed using techniques such as run-length encoding, Huffman encoding, and Elias-Fano encoding (further details will be explained in the next chapters).
\end{enumerate}