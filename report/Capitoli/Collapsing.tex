\section{Collapsing Nodes in Chains} \label{sec:collapsing}
This chapter introduces our \textbf{node collapsing} technique, designed to reduce the size of the trie by collapsing runs of Myhill--Nerode-Equivalent states adjacent in the same chain. The String Partitioning Problem provides us with a set of subsequences whose characters correspond to the nodes of the original trie; we call them chains. Within these chains, we often find consecutive nodes that are redundant from a language-theoretic perspective, specifically because they belong to the same Myhill--Nerode equivalence class.

The core idea is to merge any such sequence of consecutive, equivalent nodes into a single representative node. This operation reduces the graph structure while preserving its language. The new representative node inherits all unique incoming and outgoing transitions from the nodes it replaces, ensuring that the overall language accepted by the graph remains unchanged.

In this section, we will formally define the collapsing procedure and then rigorously prove that this transformation is language-preserving (\cref{lemma:language-eq}), guaranteeing the correctness of our compression scheme.

\begin{algorithm}[H]
\caption{$\textsc{Collapse}(N,u,v)$}
\label{alg:collapse}
\begin{algorithmic}[1]
\Require $N = (Q, \Sigma, \delta, q_0, F)$ is an NFA; $u,v \in Q$ and are MN--equivalent.
\Ensure A collapsed automaton $N'=(Q', \Sigma, \delta', q_0', F')$
    \State Create a new state $w$
    \State $Q' = (Q \setminus \{u,v\})\cup\{w\}$
    \State $\phi(z) = w \textbf{ if } z\in\{u, v\} \textbf{ else } z$
    \State $\delta' = \{ (\phi(q), a, \phi(r)) \mid (q, a, r) \in \delta \}$
    \State $q_0' = \phi(q_0)$
    \State $F' = \{ \phi(f) \mid f \in F \}$
\end{algorithmic}
\end{algorithm}

%\alessio{Ho riscritto la sezione sotto nell'\cref{alg:collapse}, valuta te se mantenerlo cosÃ¬ o come prima, diciamo che una procedura spiegata come definizione era un po' strano per me.}

%\subsection{Procedure}
% Now, we define the concept of collapsing two MN-equivalent nodes in a subsequence.
%\begin{definition}[Collapsing Two MN-equivalent States]
\begin{comment}
    \label{def:collapsing_pair}
    
    Let $N = (Q, \Sigma, \delta, q_0, F)$ be an NFA. The operation \textbf{$collapse(u,v)$} is defined for two states $u, v \in Q$ if and only if they are MN-equivalent, and transforms $N$ into a new automaton $N'=(Q', \Sigma, \delta', q_0', F')$ as follows:
    \begin{enumerate}[leftmargin=25pt]
        \item \textbf{State Merging:} A new state $w$ is created to replace $u$ and $v$. The new set of states is $Q' = (Q \setminus \{u, v\}) \cup \{w\}$.
        \item \textbf{Transition Redirection:} Let $\phi: Q \to Q'$ be a state mapping function defined as follows:
        \[
            \phi(z) = 
            \begin{cases} 
                w & \text{if } z \in \{u, v\} \\
                z & \text{otherwise}
            \end{cases}
        \]
        
        The new transition function $\delta': Q' \times \Sigma \to Q'$ is then formed by applying this mapping to the source and destination states of every transition in $\delta$:
        \[
            \delta' = \{ (\phi(q), a, \phi(r)) \mid (q, a, r) \in \delta \}
        \]
        \item \textbf{Initial and Final States:} The new initial state is $q_0' = \phi(q_0)$, and the new set of final states is $F' = \{ \phi(f) \mid f \in F \}$.
    \end{enumerate}
%\end{definition}
\end{comment}

The \textsc{Collapse} procedure forms the core of our compression strategy. By recursively applying this operation to all consecutive MN--equivalent nodes in each chain, we merge redundant states. The restriction to merge only consecutive states is critical: merging non-consecutive states, even if they share the same MN--class, would violate the total order of the chains, a property that must be preserved for the construction of the $p$--sortable automaton (\cref{def:p-sorable-automaton}) to be valid. This process transforms the initial trie into a compact $p$--sortable automaton. Such an automaton can result in an NFA, as the \textsc{Collapse} operation may introduce non-determinism. For example, if two states $u$ and $v$ are merged into a new state $w$, and there exist transitions $(u, a, s)$ and $(v, a, t)$ and $s \neq t$ after the collapsing procedure, the resulting state $w$ will have two distinct transitions for the same label $a$, which is a feature of NFAs.

\begin{example}
    Assume that we extract the chains $C_1 = \text{ACCB}$ and $C_2 = \text{BDDDDDD}$ from the trie in \cref{fig:example_ADFA} by applying the reduction from String Partitioning to MWPBM. The nodes inside each chain are the following:
    \begin{itemize}
        \item $C_1 = \{a,d,f,c\}$
        \item $C_2 = \{b,h,l,e,i,m,g\}$
    \end{itemize}
    
    Applying \cref{alg:collapse} we obtain:
    \begin{itemize}
        \item For $C_1 = (a,d,f,c)$ with classes $(A,C,C,B)$: 
        \begin{itemize}
            \item Block $B_1 = \{a\}$ (class $A$) $\rightarrow$ collapsed node $v_1$. The node $a$ is the initial state. It has two outgoing edges: $a \xrightarrow{0} b$ and $a \xrightarrow{1} c$. Since $b$ and $c$ collapse to $w_1$ and $v_3$ respectively, we obtain $v_1 \xrightarrow{0} w_1$ and $v_1 \xrightarrow{1} v_3$.
            \item Block $B_2 = \{d,f\}$ (class $C$) $\rightarrow$ collapsed node $v_2$. The outgoing edges of $d$ and $f$ are:
            \[
                d \xrightarrow{0} h,\; d \xrightarrow{1} i,\qquad
                f \xrightarrow{0} l,\; f \xrightarrow{1} m.
            \]
            After collapsing, we obtain:
            \[
                v_2 \xrightarrow{0} w_2, v_2 \xrightarrow{1} w_2,\qquad v_2 \xrightarrow{0} w_2, v_2 \xrightarrow{1} w_2.
            \]
            Since we have two identical edges we can keep only one of each.
            \item Block $B_3 = \{c\}$ (class $B$) $\rightarrow$ collapsed node $v_3$. It has two outgoing edges: $c \xrightarrow{0} f$ and $c \xrightarrow{1} g$. Since $f$ and $g$ collapse to $v_2$ and $w_2$ respectively, we obtain $v_3 \xrightarrow{0} v_2$ and $v_3 \xrightarrow{1} w_2$.
        \end{itemize}
        Result: $C_1' = (v_1, v_2, v_3)$ with classes $(A, C, B)$. Here, $v_1$ is the initial state.
        
        \item For $C_2 = (b,h,l,e,i,m,g)$ with classes $(B,D,D,D,D,D,D)$:
        \begin{itemize}
            \item Block $B_1 = \{b\}$ (class $B$) $\rightarrow$ collapsed node $w_1$. It has two outgoing edges: $b \xrightarrow{0} d$ and $b \xrightarrow{1} e$. As $d,e$ collapse to $v_2$ and $w_2$ respectively, we obtain $w_1 \xrightarrow{0} v_2$ and $w_1 \xrightarrow{1} w_2$.
            \item Block $B_2 = \{h,l,e,i,m,g\}$ (all class $D$) $\rightarrow$ collapsed node $w_2$. The node $w_2$ collects all incoming edges formerly targeting any of $b,h,l,e,i,m,g$, and it is accepting.
        \end{itemize}
        Result: $C_2' = (w_1, w_2)$ with classes $(B,D)$, and $w_2$ is the unique accepting state for this example.
    \end{itemize}
    
    The collapsed chains preserve all distinct outgoing and incoming edges through the collapse map $\Phi$, significantly reducing the space complexity from 11 nodes to 5 nodes total. The resulting $2$--sortable automaton is shown in \cref{fig:minimized_chains}.

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[->, >=stealth, node distance=3cm, on grid, auto]
            \node[state, initial, initial text=] (v1) {$v_1$};
            \node[state] (v2) [right=of v1] {$v_2$};
            \node[state] (v3) [right=of v2] {$v_3$};
            \node[state] (w1) [right=of v3] {$w_1$};
            \node[state, accepting] (w2) [right=of w1] {$w_2$};
        
            \path (v1) edge [bend left] node {0} (w1)
                    edge [bend right] node[below] {1} (v3)
                % v2 -> w1 (due archi su ancoraggi diversi)
                (v2) edge [out=40, in=140, looseness=1, shorten >=1pt] node {0} (w2.100)
                    edge [out=-40, in=250, looseness=1, shorten >=1pt] node[below] {1} (w2.260)
                % v3 -> v2 / v4 (rimangono)
                (v3) edge [bend right] node[above] {0} (v2)
                % v3 -> w1 (un arco con angolo dedicato)
                    edge [out=-30, in=220, looseness=1.3, shorten >=1pt] node[below] {1} (w2.230)
                % v4 -> w1 (due archi su ancoraggi diversi)
                (w1) edge [bend left] node {0} (v2)
                    edge [bend right] node[below] {1} (w2);
        \end{tikzpicture}
        \caption{$2$--sortable automaton obtained after collapsing consecutive MN--equivalent nodes in chains $C_1$ and $C_2$ from \cref{ex:reduction_ex}.}
        \label{fig:minimized_chains}
    \end{figure} 
\end{example}

%\subsection{Language Equivalence}

We now need to prove that the language recognized by an automaton obtained after collapsing two MN--equivalent nodes following \cref{alg:collapse} is equivalent to the language of the original automaton.

\begin{lemma} \label{lemma:language-eq}
Let $N=(Q,\Sigma,\delta,q_0,F)$ be an automaton recognizing $L \subseteq \Sigma^*$.
If two states $l,q \in Q$ correspond to the same Myhill--Nerode class for $L$ (\cref{def:myhill-nerode}), then merging $l$ and $q$ into a single state yields an automaton (possibly nondeterministic) that still recognizes exactly $L$.
\end{lemma}

\begin{proof}
By the Myhill--Nerode theorem (\cref{def:myhill-nerode}), every state of $M$ corresponds to a unique Myhill--Nerode equivalence class, and $L$ is exactly the union of those classes that intersect $L$.
If $l$ and $q$ belong to the same equivalence class, then for every continuation $z \in \Sigma^*$ we have
\[
\delta(l,z) \in F \iff \delta(q,z) \in F.
\]
Thus, replacing $l$ with $q$ (or vice versa) in any path does not affect whether the run ends in an accepting state. Therefore, merging $l$ and $q$ does not alter the set of accepted strings, i.e.\ the recognized language remains $L$.
\end{proof} 

Collapsing two MN--equivalent nodes as in \cref{alg:collapse} preserves the language of the original automaton, and the resulting chains inherit a total order. This 
directly implies that the obtained NFA is $p$--sortable and 
enables the application of the NFA indexing scheme of Cotumaccio et al.~\cite{cotumaccio2023co}.