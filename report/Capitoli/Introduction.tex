\chapter{Introduction} \label{chp:introduction}
The problem of compressing large sets of strings, or finite languages, is a fundamental challenge in computer science with applications in areas like bioinformatics, natural language processing, and data indexing. A finite language can be naturally represented by a trie. In this representation, each string in the language corresponds to a unique path from the root to a final state. Compressing the language is therefore equivalent to compressing its corresponding trie structure.

Tries are exceptionally efficient for solving problems related to string collections and prefix-based queries. Their structure makes them ideal for a variety of applications:
\begin{enumerate}
    \item \textbf{Autocomplete and Predictive Text:} Tries are widely used in search engines and text editors to suggest completions for a given prefix. By traversing the trie, all words sharing the prefix can be quickly retrieved.
    \item \textbf{Spell Checkers:} A trie can store a dictionary of valid words. To check a word, one simply traverses the trie. If the path corresponding to the word does not end in a terminal node, the word is either misspelled or not in the dictionary.
    \item \textbf{IP Routing:} In networking, routers use tries to store routing tables. This allows for efficient longest prefix matching to determine the optimal route for an IP packet.
    \item \textbf{Bioinformatics:} Tries are used to store and search large collections of DNA sequences or other biological data, enabling efficient pattern matching and analysis of shared subsequences.
\end{enumerate}

Traditional compression algorithms often fail to exploit the inherent structural properties of tries. To address this, specialized techniques have been developed. Among the most prominent is the \textit{Extended Burrows-Wheeler Transform (XBWT)}~\cite{ferragina2009compressing}, which extends the classical Burrows-Wheeler Transform~\cite{burrows1994block} to labeled trees and can be applied to tries to achieve significant compression by capturing their structural regularities.

However, existing techniques may not be optimal when dealing with tries that exhibit a high degree of repetitiveness. Such is the case for languages containing many strings with shared substrings, leading to tries with large, identical subtrees. Many real-world datasets, such as genomic databases or dictionaries of related terms, generate such highly repetitive structures. This thesis introduces and analyzes a novel compression technique specifically designed to exploit these repetitions. The core idea is to identify and merge identical subtrees by reducing the trie to its minimal deterministic finite automaton (DFA) representation. We implement this method and evaluate its performance against state-of-the-art approaches like XBWT, assessing its effectiveness on various datasets.

\section{Challenges and Contributions}
The primary goal of this thesis is to develop a data structure that both compresses a given finite language and efficiently supports indexing queries, such as navigational and subpath queries (see \cref{def:tree_operations}). This challenge involves navigating a fundamental trade-off between compression and indexability, which we explore in detail in \cref{sec:wheeler_and_psortable_graphs}. Two straightforward approaches highlight the extremes of this spectrum:

\begin{enumerate}
    \item[A] \textbf{Full Compression, Difficult Indexing:} One could minimize the input trie into the smallest possible equivalent DFA using an algorithm like Revuz's~\cite{revuz1992minimisation}. While this yields optimal compression through DAG compression (see \cref{sec:notation}), indexing the resulting general DFA is a notoriously difficult problem. As shown by Equi et al.~\cite{equiGraphsCannotBe2023}, polynomial-time indexing schemes for general DFAs cannot support sub-quadratic query times unless the Strong Exponential Time Hypothesis (SETH) fails, making this approach unsuitable for most indexing purposes.unsuitable for most indexing purposes.
    
    \item[B] \textbf{Full Indexability, No Compression:} At the other extreme, the input trie itself can be used as an index. Tries are Wheeler graphs~\cite{gagie2017wheeler}, specifically $1$--sortable automata (\cref{def:wheeler_automaton}), a property that makes them highly amenable to efficient indexing~\cite{cotumaccio2023co}. While this provides excellent query performance through the co--lexicographic ordering of states (see \cref{def:colex_order_on_automaton}), it offers no compression, as even highly repetitive subtrees are stored explicitly.
\end{enumerate}

This thesis proposes a novel algorithm that finds a sweet spot in this trade-off, which we develop throughout \cref{chp:project_overview}. The central idea is to partially minimize the input trie while ensuring that the resulting automaton remains efficiently indexable. We achieve this by leveraging the theory of $p$--sortable graphs (see \cref{sec:wheeler_and_psortable_graphs}), developing a method that strategically increases the sortability parameter $p$ (a parameter interpolating between trade-offs A and B above described) just enough to enable significant compression. The motivation for this approach is rooted in the observation that a small increase in $p$ can lead to substantial improved compression: as noted by Policriti et al.~\cite{manziniRationalConstructionWheeler2024}, there are cases where increasing $p$ from 1 to 2 allows for an exponential reduction in the automaton's size, a phenomenon we explore in detail in \cref{sec:wheeler_and_psortable_graphs}.

Our compression scheme, presented in \cref{chp:project_overview}, works by first sorting the trie's nodes by the colexicographic order of the strings connecting them to the root. Then, the scheme partitions this sorted sequence of nodes into $p$ disjoint subsequences called \emph{chains}, where each chain preserves the co--lexicographic order of its nodes. Our method optimizes this organization to merge the maximum number of adjacent Myhill--Nerode--equivalent states while ensuring $p$--sortability. 
We frame this problem as a string partitioning problem. Consider the sequence of nodes in the trie, when read in co--lexicographic order (see \cref{def:colex_order_on_automaton}), as a single long string. The ``character'' corresponding to each node is its Myhill--Nerode equivalence class (see \cref{def:myhill-nerode}), which determines if it can be merged with other nodes. The task is to partition this string of nodes into $p$ subsequences such that the number of equal-letter runs (\cref{def:run}) is minimized. Minimizing the number of runs directly corresponds to maximizing the number of merged states, yielding a compact $p$--sortable automaton. We call this problem the \emph{String Partitioning Problem} (\cref{def:string_partitioning_problem}).

\begin{restatable}[Run]{definition}{rundef}
    \label{def:run}
    Let $S = s_1s_2\ldots s_n$ be a string over an alphabet $\Sigma$. A substring $S[i \dots j] = s_i s_{i+1} \ldots s_j$ (where $1 \le i \le j \le n$) is a \textit{run} if it satisfies the following conditions:
    \begin{enumerate}
        \item \textbf{Homogeneity:} All characters in the substring are identical, i.e., $s_k = s_i$ for all $k$ such that $i \le k \le j$.
        \item \textbf{Maximality:} The substring cannot be extended to the left or right without violating homogeneity. That is:
        \begin{itemize}
            \item If $i > 1$, then $s_{i-1} \neq s_i$.
            \item If $j < n$, then $s_{j+1} \neq s_j$.
        \end{itemize}
    \end{enumerate}
\end{restatable}

\begin{restatable}{definition}{setsubseqdef}
    For a string $S = s_1s_2\ldots s_n$ over an alphabet $\Sigma$, and a set $I=\{i_1, i_2, \ldots, i_k\} \in [n]$ with $i_1 < i_2 < \cdots < i_k$, we define $S[I] := s_{i_1} s_{i_2} \ldots s_{i_k}$ as the subsequence indexed by $I$.
\end{restatable}

\begin{restatable}{definition}{runsdef}
    Let $\tau(S)$ be the number of runs in a string $S$, i.e., $\tau(S) = 1 + |\{i \in [n-1]:S[i] \neq S[i+1]\}|$.
\end{restatable}

\begin{restatable}[String Partitioning Problem]{definition}{stringpartitioningdef} \label{def:string_partitioning_problem}
    Let $\mathcal{I} = (S, p)$ be an instance of the String Partitioning Problem where $S$ is a string of length $n$ over an alphabet $\Sigma$, and $p$ is a positive integer. The output of the problem is a partition $\mathcal{P} = I_1,\dots,I_p$ of $[n]$ such that $\gamma(\mathcal{P}) = \sum_{i=1}^p \tau(S[I_i])$ is minimized.
\end{restatable}

\begin{example}[String Partitioning]
\label{ex:string-partitioning}
    Let us consider the string $S = \texttt{2213122152}$ of length 10. The number of runs in $S$ is 8, given by the decomposition $\texttt{(22)(1)(3)(1)(22)(1)(5)(2)}$.
    We want to partition the set of indices $\{1, \dots, 10\}$ into two sets, $I_1$ and $I_2$, to minimize the total number of runs in the corresponding subsequences.

    A possible partition is:
    \begin{itemize}
        \item $I_1 = \{3, 5, 8, 9\}$
        \item $I_2 = \{1, 2, 4, 6, 7, 10\}$
    \end{itemize}

    This partition yields the following subsequences:
    \begin{itemize}
        \item The subsequence corresponding to $I_1$ is $S[I_1] = \texttt{1115}$. This subsequence has 2 runs: $(\texttt{111})$ and $(\texttt{5})$.
        \item The subsequence corresponding to $I_2$ is $S[I_2] = \texttt{223222}$. This subsequence has 3 runs: $(\texttt{22})$, $(\texttt{3})$, and $(\texttt{222})$.
    \end{itemize}

    The total number of runs for this partition is $2 + 3 = 5$. This is a reduction from the original 8 runs in $S$. This example illustrates how partitioning a string's indices can reduce the total number of runs in the resulting subsequences.
\end{example}

In Section \ref{sec:reduction_to_mwpbm} we show that the String Partitioning Problem can be reduced to the problem of finding a minimum weight perfect matching on a bipartite graph (MWPBM), allowing us to use efficient, well-studied algorithms to find the optimal solution. 

To sum up, the main contribution of the thesis is to show how to convert a trie (recognizing a finite regular language) to an equivalent small compressed automaton that is $p$--sortable by construction (for any parameter $p$ specified by the user) and thus supports efficient queries using the data structure developed by Cotumaccio et al.~\cite{cotumaccio2023co}. 
The larger $p$ is, the better compression we can achieve (but the slower queries will be).
As our experimental results in \cref{chp:experiments} will show, in both the repetitive and non-repetitive scenarios our method allows for a twofold reduction of the number of states by just increasing $p$ from 1 (the original trie) to $2$. By further increasing $p$, the number of states quickly approaches that of the smallest DFA for the language. 



\section{Structure of the Thesis}
