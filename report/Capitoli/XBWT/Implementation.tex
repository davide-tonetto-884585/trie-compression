\subsection{Implementation} \label{sec:xbwt_impl}

% \nicola{Il lettore qui rimane spiazzato: stai descrivendo lo stato dell'arte e tutto ad un tratto spunta un'implementazione e degli esperimenti.  Sposta questa sezione in sezione 4 (in una sottosezione a parte) e motiva perché hai re-implementato la XBWT (cioè per compararla con il tuo compressore). }


The XBWT data structure has been implemented in C++ using the Succinct Data Structure Library 2.0 (SDSL) for efficient representation and manipulation of compressed data structures. Also, we will implement the necessary data structures and algorithms for navigating and querying the XBWT, such as parent-child navigation and path-based searches. 

The implementation of the XBWT is based on the descriptions provided in \cref{sec:XBWT} and it is available on GitHub at the following link: \url{https://github.com/davide-tonetto-884585/XBWT}.

\subsubsection{Implementation Choices}
Follows a list of the main choices made during the implementation of the XBWT:
\begin{itemize}
    \item The implementation is not focused on a specific kind of data, such as XML documents or JSON files, but it is designed to work with any kind of labeled tree. 
    \item The construction method takes as input a labeled tree. It constructs directly a compressed indexing scheme based on the Extended Burrows-Wheeler Transform of the tree as described in the previous sections.
    \item The implementation is based on the Succinct Data Structure Library (SDSL) to handle the compressed data structures generated by the XBWT. The SDSL library provides efficient implementations of various compressed data structures and algorithms, which are essential for representing and querying the XBWT efficiently.
    \item The labels of the alphabet are encoded as integers, starting from 0 to $|\Sigma| - 1$, where $|\Sigma|$ is the cardinality of the alphabet. This encoding respects the order of the labels in the alphabet and allows simplifying and reducing the space needed to store the labels in the compressed data structure. For this reason, the constructor of the XBWT class takes as input a generic labeled tree.
\end{itemize}

\subsubsection{Succinct Data Structures}
The implementation of the XBWT relies heavily on succinct data structures to achieve space efficiency while maintaining fast query operations. In particular, we use succinct data structures to compress the two main arrays of the XBWT: $S_\alpha$ and $S_{\text{last}}$. These arrays, which can be quite large for substantial trees, benefit significantly from compression.

The compression is achieved through the Succinct Data Structure Library (SDSL), which provides efficient implementations of various compressed data structures. For $S_{\text{last}}$, which is a binary sequence, we utilize a compressed bit vector that supports fast rank and select operations. For $S_\alpha$, which contains labels from a potentially large alphabet, we employ a wavelet tree structure that provides both compression and efficient query capabilities.

The SDSL is a C++ library that provides efficient implementations of various compressed data structures and algorithms. It is used in this project to handle the compressed data structures composing the XBWT. The SDSL library provides a wide range of succinct data structures, such as bit vectors, wavelet trees, and compressed suffix arrays, which are essential for representing and querying the XBWT efficiently. The library is available at \url{https://github.com/simongog/sdsl-lite}~\cite{gbmp2014sea}. Let's see the implementation details of the SDSL data structures used in the XBWT implementation.

\subsubsection{RRR Bit Vector}
The RRR bit vector is designed to provide space-efficient representations of bit vectors while supporting efficient rank and select operations. This data structure implements the RRR (Raman, Raman, and Rao) encoding method, which compresses bit vectors by partitioning them into fixed-size blocks and encoding each block based on its population count (the number of 1s) and specific configuration~\cite{raman2002succinct}. 

The space needed for an RRR bit vector of length $n$ with $m$ set bits is $nH_0 + o(n)$ ($\approx \lceil \log \binom{n}{m} \rceil$). 
The rank support is provided by \texttt{sdsl::rank\_support\_rrr}, adding $80$ bits and requiring $O(\log k)$ time for rank queries, where $k$ is the number of set bits. The select support is provided by \texttt{sdsl::select\_support\_rrr}, adding $64$ bits and requiring $O(\log n)$ time for select queries.

This data structure is used to represent $S_{\text{last}}$, a dedicated binary array $B_{\alpha}$ that stores the additional information associated with each entry of $S_{\alpha}$ (i.e., $B_{\alpha}[i]=1$ if the $i$-th symbol in $S_{\alpha}$ corresponds to a leaf and $0$ otherwise), and the $A$ array of the XBWT.

\subsubsection{Wavelet Tree}
The Wavelet tree is designed to efficiently handle sequences over large alphabets, such as integer sequences. It provides a space-efficient representation while supporting fast access, rank, and select operations. The wavelet tree is a balanced binary tree that recursively partitions the alphabet into two equal-sized subsets and encodes the sequence based on the partitioning~\cite{grossi2003high}. The \texttt{sdsl::wt\_int} uses the RRR bit vectors or other succinct representations for storing the bit vectors in each node of the wavelet tree. This makes the structure space-efficient.

If RRR-compressed bitvectors are used for the internal bitmaps, a wavelet tree over a sequence $S \in \Sigma^n$ (with $|\Sigma|=\sigma$) occupies $n H_0(S) + o(n \log \sigma) + \Theta(\sigma \log n)$ bits of space, where $H_0(S)$ is the zero-order empirical entropy of $S$, and it supports access, rank, and select queries in $O(\log \sigma)$ time.

This data structure is used to represent the $S_\alpha$ array of the XBWT.

\begin{comment}
\subsection{Details of the XBWT Class Elements}
\alessio{Questa sezione non mi convince. Non descrivere troppo il codice, la documentazione dovrebbe essere nella repo e nel codice, non nella tesi.}
The XBWT class utilizes several data structures from the SDSL library to efficiently represent and query the compressed data. Below are the details of the main elements used in the class:

\begin{itemize}
    \item \texttt{sdsl::rrr\_vector<> SLastCompressed}: This is a compressed bit vector that stores the $S_{\text{last}}$ array of the XBWT. 
    \item \texttt{sdsl::wt\_int<sdsl::rrr\_vector<>> SAlphaCompressed}: This is a wavelet tree built on top of a compressed bit vector. The wavelet tree is used to compress and index the $S_{\alpha}$ array of the XBWT.
    \item \texttt{sdsl::rrr\_vector<> SAlphaBitCompressed}: Another compressed bit vector used to store the additional bit of $S_{\alpha}$ needed to distinguish between internal and leaf nodes.
    \item \texttt{sdsl::rrr\_vector<> ACompressed}: A compressed bit vector representing the $A$ array of the XBWT used to in the $F$ array of the XBWT.
    \item \texttt{sdsl::rrr\_vector<>::rank\_1\_type SLastCompressedRank}: A rank support structure for the \texttt{SLastCompressed} bit vector, allowing efficient rank queries.
    \item \texttt{sdsl::rrr\_vector<>::select\_1\_type SLastCompressedSelect}: A select support structure for the \texttt{SLastCompressed} bit vector, allowing efficient select queries.
    \item \texttt{sdsl::rrr\_vector<>::rank\_1\_type ACompressedRank}: A rank support structure for the \texttt{ACompressed} bit vector.
    \item \texttt{sdsl::rrr\_vector<>::select\_1\_type ACompressedSelect}: A select support structure for the \texttt{ACompressed} bit vector.
    \item \texttt{std::unordered\_map<T, unsigned int> alphabetMap}: A hash map that maps each label in the alphabet to a unique integer.
    \item \texttt{unsigned int cardSigma}: The cardinality of the alphabet $\Sigma$.
    \item \texttt{unsigned int cardSigmaN}: The cardinality of the $\Sigma_N$ alphabet. Where $\Sigma_N$ is the set of labels that appear in the internal nodes of the labeled tree.
    \item \texttt{unsigned int maxNumDigits}: The maximum number of digits that has the integer code associated with the greater label in the alphabet (needed to sort the labels in the alphabet).
\end{itemize}

The overall space complexity of the XBWT class can be derived from the space complexity of the compressed data structures used in the class. 

\subsection{Construction implementation}
\alessio{Perché non fare pseudocodice come per Alg 1?}
The construction of the XBWT is done by the constructor of the XBWT class. The constructor takes as input a generic labeled tree and constructs the compressed indexing scheme using the linear pathSort (also, the naive construction method can be used by passing the boolean flag \texttt{usePathSort = false}). The construction process is divided into the following steps:

\begin{enumerate}
    \item \textbf{Alphabet Encoding}: The first step is to encode the labels of the alphabet as integers. The labels are sorted in lexicographical order and assigned a unique integer code starting from 1 to $|\Sigma|$. Two hash maps are used to map each label to a unique integer and vice versa. 
    \item \textbf{Construct \texttt{intNodes} array}: The next step is to construct the \texttt{intNodes} array as described in the previous chapters. \texttt{intNodes} is an array of triplets of length $t$ in which a node is represented as a triplet containing the node's label, its level, and the index of its parent node in the array (from $1 to t$, root has parent $0$). The nodes are inserted in a preorder traversal of the labeled tree.
    \item \textbf{Sort \texttt{intNodes} array:} Call the \texttt{pathSort} or \texttt{upwardStableSortConstruction} (naive method) method to get the sorted array of nodes \texttt{intNodes}.
    \item \textbf{Construct $S_{\text{last}}$ array}: Construct the $S_{\text{last}}$ array by iterating over the sorted \texttt{intNodes} array.
    \item \textbf{Construct $S_{\alpha}$ array}: Construct the $S_{\alpha}$ array by iterating over the sorted \texttt{intNodes} array, along with the additional bit array to distinguish between internal and leaf nodes.
    \item \textbf{Construct $A$ array}: Construct the $A$ array by iterating over the sorted \texttt{intNodes} array.
    \item \textbf{Construct rank and select support structures}: Construct the rank and select support structures for the compressed bit vectors.
\end{enumerate}

\subsection{Navigational Operations}
\alessio{Non basta dire che implementi tutte le funzioni descritte nella sezione 3.7?}

The XBWT class provides several navigational operations to traverse the labeled tree and retrieve information about the nodes. The navigational operations implemented are:

\begin{itemize}
    \item \texttt{getChildren(unsigned int i)}: This method returns a pair of integers representing the indices of the leftmost and rightmost children of the node at index \texttt{i}.
    \item \texttt{getRankedChild(unsigned int i, unsigned int k)}: This method returns the index of the \texttt{k}-th child of the node at index \texttt{i}.
    \item \texttt{getCharRankedChild(unsigned int i, T label, unsigned int k) const}: This method returns the index of the \texttt{k}-th child of the node at index \texttt{i} with the specified label.
    \item \texttt{getDegree(unsigned int i)}: This method returns the degree (number of children) of the node at index \texttt{i}.
    \item \texttt{getCharDegree(unsigned int i, T label)}: This method returns the number of children of the node at index \texttt{i} with the specified label.
    \item \texttt{getParent(unsigned int i)}: This method returns the index of the parent of the node at index \texttt{i}.
    \item \texttt{getSubtree(unsigned int i, unsigned int order = 0)}: This method returns a vector containing the labels of the nodes in the subtree rooted at index \texttt{i}. The \texttt{order} parameter specifies the traversal order (e.g., preorder, post-order).
\end{itemize}

All the methods refer to the index of the nodes in $S_{\text{last}}$ and $S_{\alpha}$ arrays. 

\subsection{Search Operations}
The XBWT class provides search operation \texttt{subPathSearch(const std::vector<T> \&path)} that searches for a subpath in the XBWT structure. It uses the compressed vectors to determine the range of positions corresponding to the nodes whose upward path is prefixed by a given vector reversed.

\end{comment}
