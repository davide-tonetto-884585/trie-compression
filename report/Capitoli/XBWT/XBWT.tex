\subsection{Definition}
The \textbf{Extended Burrows-Wheeler Transform} is a data structure designed to efficiently compress and index \emph{ordered node-labeled trees}. Inspired by the classical Burrows-Wheeler Transform (BWT) \cite{burrows1994block} for strings, the XBWT extends these principles to hierarchical structures, enabling efficient storage, navigation, and querying of trees. It is particularly effective for trees where each node has a label drawn from an alphabet $\Sigma$ and the tree structure has an arbitrary shape and degree.

\begin{definition} [Node informations]
    \label{def:node_informations}
    Let $T$ be an ordered node-labeled tree of arbitrary fan-out, depth, and shape, with $n$ internal nodes and $l$ leaves ($t$ nodes in total) and alphabet $\Sigma$. Let $u$ be a node in $T$, we define the following information:
    \begin{itemize}
        \item $last(u)$: a binary value that is 1 if $u$ is the last (rightmost) child of its parent, and 0 otherwise.
        \item $\alpha(u)$: denotes the label of node $u$ plus one bit that is 1 if $u$ is a leaf and 0 otherwise.
        \item $\pi(u)$: the string obtained by concatenating the labels of the nodes on the \textsc{upward path} from $u$'s parent to the root of $T$ (the root has an empty $\pi$ component). Note that $\pi(u) = \pi(u') \circ label(u')$ where $\circ$ is the concatenation operator.
    \end{itemize}
\end{definition}

The definition of the XBWT relies on a sorted multi-set $S$, which contains a triplet $(last(u), \alpha(u), \pi(u))$ for each node $u$ in the tree $T$.

The construction of $S$ is a two-step process. First, an intermediate multi-set is created by traversing the tree $T$ in pre-order and generating a triplet $(last(u), \alpha(u), \pi(u))$ for each node. Second, this multi-set is stably sorted according to the lexicographical order of the '$\pi$' component to produce the final multi-set $S$.

\begin{theorem}
    The XBWT of a labeled tree $T$ consists of two arrays, $S_{\text{last}}$ and $S_{\alpha}$. These are constructed from the sorted multi-set $S$ of triplets. Specifically, for each $i$ from 1 to $t$, $S_{\text{last}}[i]$ is the `$last$` component of the $i$-th triplet in $S$, and $S_{\alpha}[i]$ is the '$\alpha$' component. The total space required is $2t + t \log |\Sigma|$ bits.
\end{theorem}

$S_{\pi}$ (for each $i$ from 1 to $t$, $S_{\pi}[i]$ is the '$\pi$' component of the $i$-th triplet in $S$), therefore is not needed after the construction of the XBWT. However, in the following discussion, we will still refer to it as it possesses some important properties.

\subsection{Properties}
The XBWT's effectiveness as an indexing structure stems from a key property of the sorted multi-set $S$. This property, along with its consequences, arises directly from the transform's definition and the sorting process.

\subsubsection{Key Property: Grouping by Parent}

The fundamental property of the XBWT is that the children of any node $u$ in the tree $T$ form a contiguous block in the sorted multi-set $S$. Let $u_1, \dots, u_z$ be the children of node $u$ in their original order. Their corresponding triplets will appear consecutively in $S$ in that same order.
\begin{example}
    Consider the node $u$ in \cref{fig:example_tree}. Looking at \cref{tab:xbwt_example}, we can see that its children form a contiguous block in positions $[5, 6, 7]$ of the sorted multi-set $S$.
\end{example}

This grouping provides several important consequent properties:

\textbf{Unary Degree Encoding:} The subarray $S_{\text{last}}$ for the block of children $[u_1, \dots, u_z]$ encodes the degree of $u$ in unary. Specifically, $S_{\text{last}}[u_z] = 1$ and $S_{\text{last}}[u_i] = 0$ for $1 \leq i < z$. 
\begin{example}
    Consider the node $u$ in \cref{fig:example_tree}. Looking at \cref{tab:xbwt_example}, we can observe that $S_{\text{last}}[5 \dots 7] = \{0, 0, 1\}$, which encodes the degree 3 in unary notation, matching the number of children of node $u$.
\end{example}

\textbf{Preservation of Sibling Order:} If two nodes $u$ and $v$ have the same label, and the triplet for $u$ precedes the triplet for $v$ in $S$, then the entire block of children of $u$ will also precede the block of children of $v$.
\begin{example}
    Consider nodes $u$ and $v$ in \cref{fig:example_tree}. In \cref{tab:xbwt_example}, node $u$ appears at index 2 while node $v$ appears at index 4 in the sorted multi-set $S$. Following the preservation of sibling order property, all children of $u$ (occupying positions $[5, 6, 7]$) appear before the child of $v$ (at position $8$).
\end{example}

\textbf{Path-based Indexing:} This property extends to entire paths. For any label $c \in \Sigma$, all triplets whose $\pi$-components are prefixed by $c$ form a contiguous block in $S$. If $u$ is the $i$-th node with label $c$ in $S_{\alpha}$, its children's block is located within the larger block of all nodes with paths prefixed by $c$. This block is delimited by the $(i-1)$-th and $i$-th '1's in the corresponding section of $S_{\text{last}}$. \label{prop3}
\begin{example}
    Let's examine nodes $u$ and $v$ in \cref{fig:example_tree}, both labeled 'B'. In the sorted multi-set $S$ shown in \cref{tab:xbwt_example}, $u$ is the first node with label 'B' (at index 2), and $v$ is the second (at index 4).

    The children of all nodes labeled 'B' form a contiguous block in $S$. In this case, the children of both $u$ and $v$ are located in the range $[5, 8]$. We can distinguish between the children of $u$ and the children of $v$ using the $S_{\text{last}}$ array:
    \begin{itemize}
        \item The block of children for $u$ (the first 'B' node) starts at the beginning of the range (index 5) and ends at the position of the first '1' in $S_{\text{last}}[5\dots8]$.
        \item The block of children for $v$ (the second 'B' node) starts after the first '1' and ends at the position of the second '1' in $S_{\text{last}}[5\dots8]$.
    \end{itemize}
\end{example}

\subsubsection{Other Properties}
Additional properties of the XBWT components include:

\begin{itemize}
    \item The first triplet in $S$ always corresponds to the root of the tree $T$.
    \item $S_{\text{last}}$ contains $n$ ones (for internal nodes) and $l$ zeros (for leaves).
    \item $S_{\alpha}$ is a permutation of the node labels in $T$.
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        % Stili globali per l'albero
        level distance=1.5cm,      % Distanza verticale tra i livelli
        every node/.style={font=\sffamily}, % Usa un font sans-serif come nell'immagine
        % Stili specifici per ogni livello
        level 1/.style={sibling distance=4cm}, % Distanza tra i figli di A
        level 2/.style={sibling distance=1.5cm}, % Distanza tra i figli di B e C
        level 3/.style={level distance=1cm},     % Distanza verticale per i nodi foglia
        level 4/.style={level distance=1cm}      % Distanza verticale per i nodi foglia piÃ¹ bassi
    ]

    \node {A}
        child {
            node (B1) {B}
            child { node {D}
                child { node {a} }
            }
            child { node {a} }
            child { node {E}
                child { node {b} }
            }
        }
        child {
            node {C}
            child { node {D}
                child { node {c} }
            }
            child { node {b} }
            child { node {D}
                child { node {c} }
            }
        }
        child {
            node (B2) {B}
            child { node {D}
                child { node {b} }
            }
        };

    \node (label_u) [above left=0.2cm and 0.4cm of B1] {Node u};
    \draw[->] (label_u) -- (B1);

    \node (label_v) [above right=0.2cm and 0.4cm of B2] {Node v};
    \draw[->] (label_v) -- (B2);
    \end{tikzpicture}
    \caption{A labeled tree $T$ where $\Sigma_N = \{A, B, C, D, E\}$ and $\Sigma_L = \{a, b, c\}$. Notice that $\alpha(u) = \alpha(v) = B$ and $\pi(u) = \pi(v) = A$.}
    \label{fig:example_tree}
\end{figure}

\begin{table}[H]
    \centering
    \begin{tabular}{r c c l}
    \hline\hline
    \textbf{} & \textbf{$S_{\text{last}}$} & \textbf{$S_{\alpha}$} & \textbf{$S_{\pi}$} \\
    \hline
    \textbf{1} & 0 & A & \textit{empty string} \\
    \textbf{2} & 0 & B & A \\
    \textbf{3} & 0 & C & A \\
    \textbf{4} & 1 & B & A \\
    \textbf{5} & 0 & D & BA \\
    \textbf{6} & 0 & a & BA \\
    \textbf{7} & 1 & E & BA \\
    \textbf{8} & 1 & D & BA \\
    \textbf{9} & 0 & D & CA \\
    \textbf{10} & 0 & b & CA \\
    \textbf{11} & 1 & D & CA \\
    \textbf{12} & 1 & a & DBA \\
    \textbf{13} & 1 & b & DBA \\
    \textbf{14} & 1 & c & DCA \\
    \textbf{15} & 1 & c & DCA \\
    \textbf{16} & 1 & b & EBA \\
    \hline\hline
    \end{tabular}
    \caption{The multi-set $S$ for the tree shown in \cref{fig:example_tree}, obtained by stably sorting triplets according to their '$\pi$' components. In this representation, nodes $u$ and $v$ from the original tree $T$ appear at indices $2$ and $4$, respectively. The children's block of node $u$ occupies positions $5$ through $7$, while node $v$'s single child is located at index $8$.}
    \label{tab:xbwt_example}
\end{table}

\subsection{Construction}
A naive approach to build the XBWT would be to explicitly construct $S$ through the concretization of $\pi$-strings and then sort it using a stable sorting algorithm. However, this approach would require $\Theta(t^2)$ space in the worst case, which is not feasible for large deep trees. To overcome this issue, Ferragina et al. \cite{ferragina2009compressing} proposed a more efficient algorithm that builds $S$ in linear time and $O(t \log t)$ space.

The linear time algorithm is called \textbf{pathSort}, it is based on a generalization of the Skew algorithm for suffix array construction of strings \cite{karkkainen2006linear}. Let's see briefly how the Skew algorithm works.

\begin{comment}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{Immagini/XBWT_example.png}
    \caption[XBWT example]{(a) A labeled tree $T$ where $\Sigma_N = \{A, B, C, D, E\}$ and $\Sigma_L = \{a, b, c\}$. Notice that $\alpha[u] = \alpha[v] = B$ and $\pi[u] = \pi[v] = A$. (b) The multi-set $S$ is obtained after the pre-order visit of $T$. (c) The final multi-set $S$ after the stable sort based on the $\pi$'s component of its triplets.}
    \label{fig:XBWT_example}
\end{figure}
\end{comment}

\subsubsection{Skew Algorithm}
The Skew algorithm is an efficient method for constructing the suffix array of a string in linear time. A suffix array is a data structure that lists the starting indices of all the suffixes of a string in lexicographical order, and it is widely used in various string processing algorithms.

\subsubsection*{Algorithm Overview}

\subsubsection*{1. Divide the String}

The algorithm begins by partitioning the indices of the string into three groups based on their modulo 3 value:
\begin{itemize}
    \item $S_0$: Indices congruent to 0 mod 3.
    \item $S_1$: Indices congruent to 1 mod 3.
    \item $S_2$: Indices congruent to 2 mod 3.
\end{itemize}

The suffixes starting at positions in $S_1$ and $S_2$ are combined into a single group called $S_{12}$.

\subsubsection*{2. Sort Suffixes in $S_{12}$}

To sort the suffixes in $S_{12}$, the algorithm considers the triplets of characters starting at each position in $S_{12}$. These triplets are sorted using a linear-time sorting algorithm, such as radix sort, and then renamed by assigning each triplet an integer value representing its rank in the sorted order. If all triplets are unique, the sorting is complete; otherwise, the same procedure is applied recursively to the sequence of ranks obtained.

\subsubsection*{3. Sort Suffixes in $S_0$}

Once the suffixes in $S_{12}$ are sorted, the algorithm proceeds to sort the suffixes in $S_0$. To compare two suffixes starting at positions $i$ and $j$ in $S_0$, it compares the first characters of their respective substrings. If the characters are different, their lexicographical order is immediately determined. If they are equal, the algorithm compares the suffixes starting at positions $i+1$ and $j+1$, whose ranks are already known from the sorting of $S_{12}$.

\subsubsection*{4. Merge the Sorted Orders}

Finally, the sorted orders of the suffixes in $S_0$ and $S_{12}$ are merged to obtain the complete suffix array of the original string. This merging process can be performed in linear time, ensuring the overall efficiency of the algorithm.

\subsubsection{PathSort Algorithm} \label{sec:pathSort}

The pseudocode of the pathSort algorithm is shown in \cref{alg:pathSort}. As we can see, the algorithm is based on the Skew algorithm, but it is adapted to work on labeled trees. 
Given a value $j\in\{0,1,2\}$, the main idea is to recursively sort the upward subpaths of the tree starting at nodes in levels $\not\equiv j \pmod{3}$, then sort the upward subpaths starting at nodes in levels $\equiv j \pmod{3}$ using the result of the previous step, and finally merge the two sets of sorted subpaths by exploiting their lexicographic names. $j$ is chosen in such a way that the number of nodes of the shrunk tree whose level is $\equiv j \pmod{3}$ is at least $t/3$ so that a constant fraction of upward paths are ensured to be dropped at each recursive step.
Is important to note that:
\begin{enumerate}
    \item the height of the new (contracted) tree shrinks by a factor of three, hence the node naming requires the radix sort over triples of names; 
    \item given the choice of $j$, the number of nodes of the new (contracted) tree will be at most $2t/3$, thus ensuring that the running time of the algorithm satisfies the recurrence $R(t) = R(2t/3) + \Theta(t) = \Theta(t)$; 
    \item following an argument similar to \cite{karkkainen2006linear}, the names of the dropped subpaths can be computed in $O(t)$ time from the names of the non-dropped subpaths, by radix sorting.
\end{enumerate}

\begin{algorithm}
    \caption{\textsc{PathSort}($T$)}
    \label{alg:pathSort}
    \begin{algorithmic}[1]
    \State Create the array \texttt{IntNodes}[1, $t$], initially empty.
    \State Visit the internal nodes of $T$ in pre-order. Let $u$ denote the $i$-th visited node.
    \State Write in \texttt{IntNodes}[$i$] the symbol $\alpha(u)$, the level of $u$ in $T$, and the position in \texttt{IntNodes} of $u$'s parent.
    \State Let $j \in \{0, 1, 2\}$ be such that the number of nodes in \texttt{IntNodes} whose level is $\equiv j \pmod{3}$ is at least $t/3$. Sort recursively the upward subpaths starting at nodes in levels $\not\equiv j \pmod{3}$.
    \State Sort the upward subpaths starting at nodes in levels $\equiv j \pmod{3}$ using the result of Step 3.
    \State Merge the two sets of sorted subpaths by exploiting their lexicographic names.
    \end{algorithmic}
\end{algorithm}

\subsubsection{Recursive Step of PathSort}
At each recursive step, the algorithm constructs the array \texttt{IntNodes}, which stores the triplets $(\alpha(u), \text{level}(u), \text{parent}(u))$ for every internal node $u$ in the given tree $T$.  

Next, the algorithm selects a value $j$ such that the number of nodes in \texttt{IntNodes} with depth $\equiv j \pmod{3}$ is at least $t/3$. Based on this choice, two separate arrays are created:  
\begin{itemize}
    \item \texttt{IntNodesAtPosJ}, containing nodes at levels $\equiv j \pmod{3}$,
    \item \texttt{IntNodesNotAtPosJ}, containing nodes at levels $\not\equiv j \pmod{3}$
\end{itemize}

For each node $u$ in \texttt{IntNodesNotAtPosJ}, the algorithm extracts the upward path consisting of the first three ancestors of $u$. These paths are then sorted using radix sort. If the sorted upward paths contain duplicates, the algorithm recursively calls the PathSort function on a new contracted tree, where nodes are renamed according to their sorted paths. Otherwise, if all upward paths are unique, the nodes in \texttt{IntNodesAtPosJ} are sorted and subsequently merged with \texttt{IntNodesNotAtPosJ} using lexicographic ordering, following the same merging strategy as in the Skew algorithm.

\subsection{Inversion}
The ability to invert the XBWT is fundamental to its utility as a compression technique. Invertibility guarantees that the original tree can be perfectly reconstructed from its transformed representation ($S_{\text{last}}$ and $S_{\alpha}$). This ensures that the compression is lossless, meaning no information is lost during the process, which is a critical requirement for most applications.

Property 'Path-based Indexing' (\cref{prop3}) ensures that the two arrays $S_{\text{last}}$ and $S_{\alpha}$ of the XBWT can be used to reconstruct the original tree $T$. The algorithm to invert the XBWT is linear in time and requires $O(t \log t)$ bits of space.

\cref{alg:rebuildTree} operates in three main steps. First, it constructs two auxiliary arrays, $F$ and $J$, which are crucial for navigating the tree structure within the compressed format.

\begin{itemize}
    \item \textbf{The $F$ array:} This array maps each character $c \in \Sigma$ to the index of the first occurrence in $S$ of a triplet whose $\pi$-component is prefixed by $c$. It essentially marks the starting points of blocks of nodes that share the same initial path label.
    \item \textbf{The $J$ array:} For each entry $i$ in $S$, $J[i]$ stores the index in $S$ corresponding to the first child of the node represented by $S[i]$. If $S[i]$ represents a leaf, $J[i]$ is set to a sentinel value (e.g., -1).
\end{itemize}

\begin{example}[$F$ and $J$ arrays]
    Considering the XBWT in \cref{tab:xbwt_example}, the $F$ array would map 'A' to index 2 (for node $r$), 'B' to index 5 (for the children of nodes with label 'B'), and so on. For the $J$ array, let's take the node $u$ at index 2 in $S$. Its first child is at index 5. Therefore, $J[2]$ would be 5.
\end{example}

Finally, the algorithm employs the array $J$ to
simulate a depth-first visit of $T$, creates its labeled nodes, and properly connects them to their parents. 

\begin{algorithm}[H]
    \caption{RebuildTree(\texttt{XBWT[$T$]})}
    \label{alg:rebuildTree}
    \begin{algorithmic}[1]
    \State $F = $ BuildF(\texttt{XBWT[$T$]});
    \State $J = $ BuildJ(\texttt{XBWT[$T$]}, $F$); 
    \State Create node $r$ and set $Q = \{\langle1, r\rangle\}$; \Comment{$Q$ is a stack}
    \While{$Q \neq \emptyset$} \Comment{We still have nodes to create in $T$}
        \State $\langle i, u \rangle = $ pop($Q$);
        \State $j = J[i]$; \Comment{Take the block of $u$'s children in $S$}
        \If{$j = -1$} \Comment{$u$ is a leaf of $T$}
            \State \textbf{continue};
        \EndIf
        \State Find first $j' \geq j$ such that $S_{\text{last}}[j'] = 1$; \Comment{$S[j, j']$ are the children of $u$ in $T$}
        \For{$h = j'$ downto $j$} \Comment{Recall that $Q$ is a stack}
            \State Create the node $v$ labeled $S_\alpha[h]$;
            \State Attach $v$ as first child of $u$;
            \State push($\langle h, v \rangle$, $Q$);
        \EndFor
    \EndWhile
    \State \Return node $r$.
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{BuildF(\texttt{XBWT[$T$]})}
    \label{alg:buildF}
    \begin{algorithmic}[1]
    \For{$i = 1, \ldots, |\Sigma_N|$}
        \State $C[S_\alpha[i]] \gets C[S_\alpha[i]] + 1$; \Comment{Count the occurrences of node labels}
    \EndFor
    \State $F[1] = 2$; \Comment{$S_\pi[1]$ is the empty string}
    \For{$i \in \{1, \ldots, |\Sigma_N|-1\}$} \Comment{Consider just the internal-node labels}
        \State $s = 0$; $j = F[i]$;
        \While{$s \neq C[i]$} \Comment{Not all blocks of children have been passed}
            \State $j = j + 1$;
            \If{$S_{\text{last}}[j] = 1$} \Comment{One further block of children has passed}
                \State $s = s + 1$;
            \EndIf
        \EndWhile
        \State $F[i+1] = j$;
    \EndFor
    \State \Return $F$.
    \end{algorithmic}
\end{algorithm}
    
\begin{algorithm}[H]
    \caption{BuildJ(\texttt{XBWT[$T$]}, $F$)}
    \begin{algorithmic}[1]
    \For{$i = 1, \ldots, t$}
        \If{$S_\alpha[i] \in \Sigma_L$}
            \State $J[i] = -1$; \Comment{$S_\alpha[i]$ is a leaf label}
        \Else
            \State $z = J[S_\alpha[i]]$;
            \While{$S_{\text{last}}[z] \neq 1$} \Comment{Reach the last child of $S_\alpha[i]$}
                \State $z = z + 1$;
            \EndWhile
            \State $F[S_\alpha[i]] = z + 1$;
        \EndIf
    \EndFor
    \State \Return $J$.
    \end{algorithmic}
\end{algorithm}

\subsection{Compressing Labeled Trees}
\begin{comment}
Let the $k$-context of a node $u \in T$ be the first $k$ symbols of $\pi(u)$. We denote this $k$-long prefix as $\pi_k[u]$. Thus, $\pi_k[u]$ represents the subpath of length $k$ leading to $u$ in $T$, or equivalently, the node $u$ descends from a subpath labeled as $\pi_k[u]$, where the nodes in $\pi_k[u]$ are encountered in an upward direction.
\end{comment}

The XBWT[$T$] exhibits a local homogeneity property on the string $S_{\alpha}$, specifically, node labels get distributed over $S_{\alpha}$ in accordance with a pattern that clusters closely the labels that descend from `similar' upward paths sharing long prefixes. Which can be demonstrated through the concept of $k$-contexts on trees. 
This property mirrors the strong local homogeneity exhibited by strings under the Burrows-Wheeler Transform \cite{burrows1994block} when applied to labeled trees.

To illustrate this, let us consider two arbitrary nodes $u$ and $v$ in $T$, and examine their contexts $\pi(u)$ and $\pi(v)$. Given the sorting of $S$, the greater the length of the shared prefix between $\pi(u)$ and $\pi(v)$, the closer the corresponding labels $\alpha(u)$ and $\alpha(v)$ will be in the string $S_{\alpha}$. These closely spaced labels are expected to be few in number, resulting in $S_{\alpha}$ exhibiting local homogeneity. As a consequence, we can leverage the advanced algorithmic techniques developed for BWT-based compression methods to achieve efficient compression.

At the end, the XBWT is used for turning the labeled tree compression problem into a string compression problem. To this aim, two string compressors
$C_{\alpha}$ and $C_{\text{last}}$ are used to compress the two strings that compose XBWT[$T$], by exploiting their fine specialties. Of course, many choices are possible for $C_{\alpha}$ and $C_{\text{last}}$, each having implications on the algorithmic time and compression bounds.

In general, the following theorem holds:

\begin{theorem}
    let $C_{\alpha}$ be a $k$-th order string compressor that compresses any string $w$ into $|w|H_k(w) + |w| + o(|w|)$ bits, taking $O(|w|)$ time; and let $C_{\text{last}}$ be an algorithm that stores $S_{\text{last}}$ without compression. With this simple instantiation, the labeled tree $T$ can be compressed within $t H_k(S_{\alpha}) + 2t + o(t)$ bits and takes $O(t)$ optimal time.
\end{theorem}

Since $H_k(S_\alpha) \leq (\log |\Sigma|) + 1,^6$ the above bound is at most $t(\log |\Sigma| + 3) + o(t)$ bits, and can be significantly better than the information-theoretic lower bound and the plain storage of XBWT[$T$] (both taking $2t + t \log|\Sigma|$ bits), depending on the distribution of the labels among its nodes.

\subsection{Indexing a Compressed Labeled Tree} \label{sec:xbwt_operations}
In order to implement the efficient operations listed in \cref{compandindexinglabtree} using the compressed arrays $S_{\text{last}}$ and $S_{\alpha}$ of XBWT, we need that the chosen compressors $C_{\alpha}$ and $C_{\text{last}}$ support the following operations:

Given a string $S[1, t]$ over alphabet $\Sigma$
\begin{itemize}
    \item \textbf{$rank_c(S, q)$}: gives the number of times the symbol $c \in \Sigma$ appears in $S[1, q]$.
    \item \textbf{$select_c(S, i)$}: gives the position of the $i$-th occurrence of the symbol $c \in \Sigma$ in $S$.
\end{itemize}

The compressed indexing of XBWT[$T$] will be based on three compressed data structures that support rank and select queries over the two strings $S_{\alpha}$ and $S_{\text{last}}$, and over an auxiliary binary array $A[1, t]$ defined as: $A[1] = 0$, $A[j] = 1$ if and only if the first symbol of $S_{\pi}[j]$ differs from the first symbol of $S_{\pi}[j - 1]$. 
Hence, $A$ contains at most $|\Sigma| + 1$ bits set to 1 out of $t$ positions. It is also easy to see that, through rank and select operations over $A$, we can succinctly implement the array $F$ employed in \cref{alg:rebuildTree,alg:buildF}.

The following methods are supported by the compressed index:

\textbf{GetRankedChild(i, k)}: Returns the position in $S$ of the $k$-th child of the node at index $i$. If the child does not exist, it returns -1. 
\begin{example}
    In \cref{tab:xbwt_example}, \texttt{GetRankedChild(2, 2)} returns 6.
\end{example}

\textbf{GetCharRankedChild(i, c, k)}: Returns the position in $S$ of the $k$-th child labeled $c$ of the node at index $i$. If the child does not exist, it returns -1.
\begin{example}
    In \cref{tab:xbwt_example}, \texttt{GetCharRankedChild(1, B, 2)} returns 4.
\end{example}

\textbf{GetDegree(i)}: Returns the total number of children of the node at index $i$ in $S$.

\textbf{GetCharDegree(i, c)}: Returns the number of children of the node at index $i$ in $S$ that have the label $c$.

\textbf{GetParent(i)}: Returns the position in $S$ of the parent of the node at index $i$. If the node is the root (at index 1), it returns -1.
\begin{example}
    In \cref{tab:xbwt_example}, \texttt{GetParent(8)} returns 4.
\end{example}

\textbf{GetSubtree(i)}: Retrieves the labels of all nodes in the subtree rooted at the node at index $i$ in $S$. The labels can be returned in any standard traversal order (e.g., pre-order, in-order, or post-order).

\textbf{SubPathSearch($P$)}: For a given labeled path $P = c_1c_2 \cdots c_k$, this function finds the range $S[\text{First} \dots \text{Last}]$ containing the immediate children of all nodes that match the path $P$. Meaning that all strings in $S_{\pi}[\text{First} \dots \text{Last}]$ are prefixed by the reversed path $P^R = c_k \cdots c_2c_1$, as the strings in $S_{\pi}$ are constructed using upward paths.
\begin{example}
    In \cref{tab:xbwt_example}, \texttt{SubPathSearch(BD)} results in the range [12, 13], and \\ \texttt{SubPathSearch(AB)} gives the range [5, 8].
\end{example}

It is important to note that their time complexity is dependent on the specific implementation for rank and select over the compressed strings $S_{\alpha}$ and $S_{\text{last}}$. 

Let's now see how to implement some of the above methods (from which the others can be derived) using the rank and select operations over the compressed strings $S_{\alpha}$ and $S_{\text{last}}$.

\begin{table}
    \centering
    \begin{tabular}{r c c c l}
    \hline\hline
    \textbf{} & $A$ & \textbf{$S_{\text{last}}$} & \textbf{$S_{\alpha}$} & \textbf{$S_{\pi}$} \\
    \hline
    \textbf{1} & 0 & 0 & A & \textit{empty string} \\
    \textbf{2} & 1 & 0 & B & A \\
    \textbf{3} & 0 & 0 & C & A \\
    \textbf{4} & 0 & 1 & B & A \\
    \textbf{5} & 1 & 0 & D & BA \\
    \textbf{6} & 0 & 0 & a & BA \\
    \textbf{7} & 0 & 1 & E & BA \\
    \textbf{8} & 0 & 1 & D & BA \\
    \textbf{9} & 1 & 0 & D & CA \\
    \textbf{10} & 0 & 0 & b & CA \\
    \textbf{11} & 0 & 1 & D & CA \\
    \textbf{12} & 1 & 1 & a & DBA \\
    \textbf{13} & 0 & 1 & b & DBA \\
    \textbf{14} & 0 & 1 & c & DCA \\
    \textbf{15} & 0 & 1 & c & DCA \\
    \textbf{16} & 1 & 1 & b & EBA \\
    \hline\hline
    \end{tabular}
    \caption{The multi-set $S$ for the tree shown in \cref{fig:example_tree}, obtained by stably sorting triplets according to their '$\pi$' components. In this representation, nodes $u$ and $v$ from the original tree $T$ appear at indices $2$ and $4$, respectively. The children's block of node $u$ occupies positions $5$ through $7$, while node $v$'s single child is located at index $8$. Also, the auxiliary binary array $A$ is shown.}
    \label{tab:xbwt_example_2}
\end{table}

\subsubsection*{GetChildren(i)}
\cref{alg:getchildren} exploits directly the properties described before, in particular Property `Path-based Indexing' (\cref{prop3}). The rank operation at line 5 is used to get the number $r$ of nodes labeled $c$ up to position $i$ in $S_{\alpha}$. Then, the position $F[c]$ is obtained through a select operation on $A$ (line 6). By Property `Path-based Indexing', the children of $S[i]$ are located at the $r$-th block of children following position $F[c]$. Lines $8 - 9$ identify this block. 

\begin{example}
    Let's walk through an example using \cref{tab:xbwt_example_2}. Consider the node $u$ at index 2 labeled with $B$. To find its children:

    \begin{enumerate}
        \item First, we compute $r = 1$ since this is the first occurrence of $B$ in $S_{\alpha}$ up to position 2.
        \item Next, we find $y = F[B] = 5$, which marks the start of the block containing children of all nodes labeled $B$.
        \item Then, we count $z = 1$ ones in $S_{\text{last}}$ up to position $y-1$.
        \item Finally, the children block is delimited by the $z+r-1 = 1$st and $z+r = 2$nd ones in $S_{\text{last}}$, giving us the range $[5,7]$.
    \end{enumerate}

    This range $[5,7]$ indeed contains the three children of the node at index 2, as we can verify from the tree structure in \cref{fig:example_tree}.
\end{example}

\begin{algorithm}[H] 
    \caption{GetChildren($i$)}
    \label{alg:getchildren}
    \begin{algorithmic}[1]
    \If{$S_\alpha[i] \in \Sigma_L$}
        \State \Return $-1$ \Comment{$S[i]$ is a leaf}
    \EndIf
    \State $c \gets S_\alpha[i]$ \Comment{$S[i]$ is labeled $c$}
    \State $r \gets \text{rank}_c(S_\alpha, i)$
    \State $y \gets \text{select}_1(A, c)$ \Comment{$y = F[c]$}
    \State $z \gets \text{rank}_1(S_{\text{last}}, y - 1)$
    \State $\text{First} \gets \text{select}_1(S_{\text{last}}, z + r - 1) + 1$
    \State $\text{Last} \gets \text{select}_1(S_{\text{last}}, z + r)$
    \State \Return $(\text{First}, \text{Last})$
    \end{algorithmic}
\end{algorithm}

\subsubsection*{GetParent(i)}
\cref{alg:getparent} is based on Property `Path-based Indexing' (\cref{prop3}) and it is the inverse of the GetChildren method. In line 4, the algorithm computes the label $c$ of the parent of $S[i]$ that prefixes the upward path leading to $S[i]$. Then, the parent of $S[i]$ is searched among the nodes labeled $c$ in $S_{\alpha}$ by exploiting Property `Path-based Indexing' in a reverse manner. Namely, the number $k$ of children-blocks in the range $S[y, i]$ is computed; these are children of nodes labeled $c$ and preceding $i$ in the stable sort of $S$. Then, the $k$-th occurrence of $c$ in $S_{\alpha}$ is selected, which is indeed the parent of $S[i]$.

\begin{example}
    Let's illustrate how to find a node's parent using \cref{tab:xbwt_example_2}. Consider node $v$ located at index 4 with label $B$. The process to find its parent involves:
    \begin{enumerate}
        \item Computing $c = \text{rank}_1(A, 4) = 1$, which tells us the parent has label `A' (as $A$ contains exactly one 1 up to position 4).
        \item Locating $y = F[A] = 2$, which indicates where the block of children for nodes labeled `A' begins.
        \item Calculating $k = \text{rank}_1(S_{\text{last}}, 4-1) - \text{rank}_1(S_{\text{last}}, 2-1) = 0$, meaning no complete child blocks appear before position 4.
        \item Therefore, $v$'s parent is the first ($(k+1)$-th) occurrence of `A' in $S_{\alpha}$, corresponding to index 1 (the root of $\mathcal{T}$).
    \end{enumerate}
    This example demonstrates how the XBWT structure efficiently encodes parent-child relationships using just the $S_{\text{last}}$ and $S_{\alpha}$ arrays.
\end{example}

\begin{algorithm}[H]
    \caption{GetParent($i$)}
    \label{alg:getparent}
    \begin{algorithmic}[1]
    \If{$i = 1$}
        \State \Return $-1$ \Comment{$S[i]$ is the root of $\mathcal{T}$}
    \EndIf
    \State $c \gets \text{rank}_1(A, i)$
    \State $y \gets \text{select}_1(A, c)$
    \State $k \gets \text{rank}_1(S_{\text{last}}, i - 1) - \text{rank}_1(S_{\text{last}}, y - 1)$
    \State $p \gets \text{select}_c(S_\alpha, k + 1)$
    \State \Return $p$
    \end{algorithmic}
\end{algorithm}

\subsubsection*{SubPathSearch($P$)}
We assume that $P = c_1c_2 \cdots c_k$ algorithm SubPathSearch computes the range $[First, Last]$ in $|P| = l$ phases, each one preserving the following invariant:

\begin{itemize}
    \item Invariant of Phase $i$. At the end of the phase, $S_{\pi}[First]$ is the first entry prefixed by $P[1, i]^R$ , and $S_{\pi}[Last]$ is the last entry prefixed by $P[1, i]^R$ , where $s^R$ is the reversal of string $s$.
\end{itemize}

At the beginning (i.e., $i = 1$), First and Last are easily determined via the entries $F[c_1]$ and $F[c_1 + 1] - 1$, which point to the first and last entry of $S_{\pi}$ prefixed by $c_1$ (by definition of array $F$). Since we do not have the $F$ array, we implement these operations via rank and select queries over array $A$. Let us assume that the invariant holds for Phase $i - 1$, and prove that the $i$-th iteration of the for-loop in algorithm SubPathSearch preserves the invariant. More precisely, let $S_{\pi}[First, Last]$ be all entries prefixed by $P[1, i - 1]^R$. So $S[First, Last]$ contains all nodes descending from $P[1, i - 1]$. SubPathSearch determines $S[z_1]$ (respectively $S[z_2]$) as the first (respectively last) node in $S[First, Last]$ that descends from $P[1, i - 1]$ and is labeled $c_i$, if any. Then it jumps to the first child of $S[z_1]$ and the last child of $S[z_2]$. From Property 2 (item 2) and the correctness of algorithms GetChildren and GetDegree, we infer that the positions of these two children are exactly the first (respectively last) entry in $S$ whose $\pi$-component is prefixed by $P[1, i]^R$. 

The time complexity of the SubPathSearch algorithm is $O(l)$, where $l$ is the length of the input path $P$.

\begin{example}
    Consider the tree in \cref{fig:example_tree}, and let $P = BD$. The algorithm \textsc{SubPathSearch}($P$) returns the range $[12, 13]$ through the following steps:

    \begin{enumerate}
        \item Initially, $First = F[B] = 5$ and $Last = F[C] - 1 = 8$. The range $S[5,8]$ contains all nodes descending from paths prefixed by $B$.
        
        \item For $c_2 = D$:
        \begin{itemize}
            \item Compute $k_1 = 0$ and $k_2 = 2$
            \item This yields $z_1 = 5$ and $z_2 = 8$
            \item The first child of $S[5]$ is at position $12$
            \item The last (and only) child of $S[8]$ is at position $13$
        \end{itemize}
        
        \item Therefore, the algorithm returns the range $[12,13]$
    \end{enumerate}

    Note that both the number of offspring and the number of occurrences of subpath $P$ are 2, as evidenced by the two occurrences of 1 in $S_{\text{last}}[12,13]$.
\end{example}

\begin{algorithm}[H]
    \caption{SubPathSearch($P$)}
    \label{alg:subpathsearch}
    \begin{algorithmic}[1]
    \State $First \gets F(c_1)$; $Last \gets F(c_1 + 1) - 1$
    \If{$First > Last$}
        \State \textbf{return} ``$P$ is not a subpath of $T$''
    \EndIf
    \For{$i \gets 2, \dots, k$}
        \State $k_1 \gets \text{rank}_{c_i}(S_\alpha, First - 1)$; $z_1 \gets \text{select}_{c_i}(S_\alpha, k_1 + 1)$
        \Comment{first entry in $S_\alpha[First, t]$ labeled $c_i$}
        \State $k_2 \gets \text{rank}_{c_i}(S_\alpha, Last)$; $z_2 \gets \text{select}_{c_i}(S_\alpha, k_2)$
        \Comment{last entry in $S_\alpha[1, Last]$ labeled $c_i$}
        \If{$z_1 > z_2$}
            \State \textbf{return} ``$P$ is not a subpath of $T$''
        \EndIf
        \State $First \gets \text{GetRankedChild}(z_1, 1)$ \Comment{get the first child of $S[z_1]$}
        \State $Last \gets \text{GetRankedChild}(z_2, \text{GetDegree}(z_2))$ \Comment{get the last child of $S[z_2]$}
    \EndFor
    \State \textbf{return} $(First, Last)$
    \end{algorithmic}
\end{algorithm}
