\section[The Extended Burrows-Wheeler Transform]{The Extended Burrows-Wheeler \\ Transform} \label{sec:XBWT}
%The fundamental definitions, properties, and algorithms related to the Extended Burrows-Wheeler Transform presented in this chapter are based on the work introduced by Ferragina et al.~`Compressing and Indexing Labeled Trees, with Applications'~\cite{ferragina2009compressing}.
This section explores the Extended Burrows-Wheeler Transform (XBWT), a state-of-the-art technique for labeled tree compression.
We are interested in the XBWT for the following reasons:
\begin{itemize}
    \item It provides a powerful theoretical foundation for indexing labeled trees and tries. Tries are a special case of a broader class of graphs known as Wheeler graphs, and the XBWT can be understood as a compressed index specifically for this special case. This context is crucial, as the work of Cotumaccio et al.~\cite{cotumaccio2021indexing} later generalized the principles of the XBWT to the larger class of $p$--sortable graphs (\cref{sec:wheeler_and_psortable_graphs}).
    \item It will serve as the primary benchmark against which we will evaluate the novel compression scheme proposed in this thesis. By establishing a baseline with a well-regarded and theoretically significant method like the XBWT, we can effectively demonstrate the potential advantages and contributions of our new approach, particularly for trees exhibiting high repetitiveness.
\end{itemize}

% E\subsection{Introduction and Motivation}
In 2005, Ferragina et al.~\cite{ferragina2009compressing} introduced an innovative approach to labeled tree compression by transforming it into a more tractable string compression problem. Their key contribution, the XBWT, is a sophisticated data structure that achieves highly efficient compression by combining entropy-compressed edge labels with a succinct representation of the tree topology. This elegant solution not only simplifies the compression process but also maintains the structural relationships, essential for tree operations.

\begin{comment}
\draft{As explained in \cref{sec:state-of-the-art}, the XBWT works by linearizing a labeled tree into two coordinated arrays, one capturing the structural properties of the tree and the other storing its labels. The key advantage of the XBWT lies in its ability to compress labeled trees while supporting a wide range of operations, such as navigation, visualization and subpath queries (see \cref{def:tree_operations}), within (near-)optimal time bounds and entropy-bounded space.} \alessio{This is basically the same paragraph of the SOTA, is it necessary to keep it here? It will be explained in detail anyways in the next subsection.}
\end{comment}

One of the primary applications of the XBWT is compressing and indexing hierarchical data formats, such as XML documents. It provides significant improvements in both compression ratio and query performance compared to traditional tools, making it an invaluable resource for data-intensive applications in fields like bioinformatics, information retrieval, and big data analytics.

This section aims to explore the XBWT data structure and its applications in the context of labeled trees. We will start by providing an overview of the theoretical foundations of the XBWT. Finally, we will describe and compare the algorithms for constructing the XBWT and demonstrate its use in compressing and indexing labeled trees.

\begin{comment}
\subsection{How it Works}
The transformation process of the XBWT is as follows:
\begin{enumerate}
    \item \textbf{Path Sorting:} The labeled tree is linearized by sorting its nodes based on the \emph{paths} from each node's parent to the root. The resulting order groups nodes with similar upward paths together, clustering related labels.
    \item \textbf{Array Construction:} Two arrays, \( S_{\text{last}} \) and \( S_{\alpha} \), are generated:
    \begin{itemize}
        \item \( S_{\text{last}} \) stores structural information, such as whether a node is the last child of its parent. This encodes the tree structure without the need for explicit pointers.
        \item \( S_{\alpha} \) stores the labels of the nodes in the sorted order determined by their upward-path sorting.
    \end{itemize}
    \item \textbf{Compression:} Both \( S_{\text{last}} \) and \( S_{\alpha} \) are highly compressible due to the clustering of similar labels and structural redundancy.
\end{enumerate}
\end{comment}

\begin{comment}
\subsection{XBWT implementation overview}
\alessio{Solitamente è meglio separere la parte teorica dalla parte implementativa. La struttura del progetto in ogni caso non aggiunge così tante informazioni, anche perché hai usato nomi molto self-explanatory. Valuta se lasciare o togliere l'itemize.}

\alessio{Quando la tesi sarà letta, questo è un lavoro già fatto. Usa il presente storico il passato.}
The XBWT data structure \draft{will} be implemented in C++ using the Succinct Data Structure Library 2.0 (SDSL) for efficient representation and manipulation of compressed data structures. We will develop two algorithms for constructing the XBWT: one efficient linear-time recursive algorithm and one more straightforward iterative algorithm. Also, we will implement the necessary data structures and algorithms for navigating and querying the XBWT, such as parent-child navigation and path-based searches. 

The code is available on GitHub at \url{https://github.com/davide-tonetto-884585/XBWT}. The project will be structured as follows:

\begin{itemize}
    \item \textbf{XBWT.hpp}: File containing the class definition and implementation for the generic XBWT data structure.
    \item \textbf{LabeledTree.hpp}: File containing the class definition and implementation for the generic labeled tree data structure used to feed and test the XBWT.
    \item \textbf{main.cpp}: Main file containing the test cases and examples for the XBWT implementation.
    \item \textbf{experiments.cpp}: File containing the experiments and performance evaluation of the XBWT construction algorithms and compression efficiency.
    \item \textbf{CMakeLists.txt}: CMake configuration file for building the project.
\end{itemize}
\end{comment}
