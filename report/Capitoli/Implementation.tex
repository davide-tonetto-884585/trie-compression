\chapter{Implementation of the XBWT}

The implementation of the XBWT is based on what has been described in the previous chapters. The implementation is written in C++ and is available on GitHub at the following link: \url{https://github.com/davide-tonetto-884585/XBWT}.

\section{Implementation choices}
Follows a list of the main choices made during the implementation of the XBWT:
\begin{itemize}
    \item The implementation is not focused on working for a specific kind of data such as XML documents or JSON files, but it is designed to work with any kind of labeled tree. 
    \item The construction method of the XBWT class takes as input a labeled tree, and construct directly a compressed indexing scheme for it based on the Extended Burrows-Wheeler Transform of the tree as described in the previous chapters.
    \item In order for the XBWT to work we assume that the labels of the leaf nodes of the given labeled tree are lexicographically greater than the labels of the internal nodes. This is necessary to ensure that the navigational and search operations work correctly.
    \item The implementation is based on the Succinct Data Structure Library (SDSL) to handle the compressed data structures generated by the XBWT. The SDSL library provides efficient implementations of various compressed data structures and algorithms, which are essential for representing and querying the XBWT efficiently.
    \item The labels of the alphabet are encoded as integers, starting from 0 to $|\Sigma| - 1$, where $|\Sigma|$ is the cardinality of the alphabet. This encoding respect the order of the labels in the alphabet and allows simplifying and reduce the space needed to store the labels in the compressed data structures. For this reason the constructor of the XBWT class takes as input a generic labeled tree.
\end{itemize}

\subsection{Succinct Data Structure Library (SDSL)}
The Succinct Data Structure Library (SDSL) is a C++ library that provides efficient implementations of various compressed data structures and algorithms. It is used in this project to handle the compressed data structures generated by the XBWT. The SDSL library provides a wide range of succinct data structures, such as bit vectors, wavelet trees, and compressed suffix arrays, which are essential for representing and querying the XBWT efficiently. The library is available at \url{https://github.com/simongog/sdsl-lite} \cite{gbmp2014sea}. Let's see the implementation details of the SDSL data structures used in the XBWT implementation.

\subsubsection{sdsl::rrr\_vector}
The \texttt{sdsl::rrr\_vector} is a class of the Succinct Data Structure Library (SDSL), designed to provide space-efficient representations of bit vectors while supporting efficient rank and select operations. This data structure implements the RRR (Raman, Raman, and Rao) encoding method, which compresses bit vectors by partitioning them into fixed-size blocks and encoding each block based on its population count (the number of 1s) and specific configuration \cite{raman2002succinct}.

The space needed by \texttt{sdsl::rrr\_vector} for a bit vector of length $n$ with $m$ set bits is $nH_0 + o(n)$ ($\approx \lceil \log \binom{n}{m} \rceil$). The rank support is provided by \texttt{sdsl::rank\_support\_rrr} adding $80$ bits and requiring $O(\log k)$ time for rank queries, where $k$ is the number of set bits. The select support is provided by \texttt{sdsl::select\_support\_rrr} adding $64$ bits and requiring $O(\log n)$ time for select queries.

\subsubsection{sdsl::wt\_int}
The \texttt{sdsl::wt\_int} is a class of the Succinct Data Structure Library (SDSL) that implements wavelet trees designed to efficiently handle sequences over large alphabets, such as integer sequences. It provides a space-efficient representation while supporting fast access, rank, and select operations. The wavelet tree is a balanced binary tree that recursively partitions the alphabet into two equal-sized subsets and encodes the sequence based on the partitioning \cite{grossi2003high}. The \texttt{sdsl::wt\_int} uses the RRR compressed bit vectors or other succinct representations for storing the bit vectors in each node of the wavelet tree.
This makes the structure space-efficient.

In the case of RRR compressed bit vectors the space needed by \texttt{sdsl::wt\_int} for a sequence of length $n$ over an alphabet of size $\sigma$ is $nH_0(S) + o(n \log \sigma) + \Theta(\sigma \log n)$ bits, where $H_0(S)$ is the zero-order empirical entropy of the sequence $S$. Also supports query access, rank and select operations in $O(\log \sigma)$ time.

\subsection{Details of the XBWT Class Elements}
The XBWT class utilizes several data structures from the SDSL library to efficiently represent and query the compressed data. Below are the details of the main elements used in the class:

\begin{itemize}
    \item \texttt{sdsl::rrr\_vector<> SLastCompressed}: This is a compressed bit vector that stores the $S_{\text{last}}$ array of the XBWT. 
    \item \texttt{sdsl::wt\_int<sdsl::rrr\_vector<>> SAlphaCompressed}: This is a wavelet tree built on top of a compressed bit vector. The wavelet tree is used to compress and index the $S_{\alpha}$ array of the XBWT.
    \item \texttt{sdsl::rrr\_vector<> SAlphaBitCompressed}: Another compressed bit vector used to store the additional bit of $S_{\alpha}$ needed to distinguish between internal and leaf nodes.
    \item \texttt{sdsl::rrr\_vector<> ACompressed}: A compressed bit vector representing the $A$ array of the XBWT used to in the $F$ array of the XBWT.
    \item \texttt{sdsl::rrr\_vector<>::rank\_1\_type SLastCompressedRank}: A rank support structure for the \texttt{SLastCompressed} bit vector, allowing efficient rank queries.
    \item \texttt{sdsl::rrr\_vector<>::select\_1\_type SLastCompressedSelect}: A select support structure for the \texttt{SLastCompressed} bit vector, allowing efficient select queries.
    \item \texttt{sdsl::rrr\_vector<>::rank\_1\_type ACompressedRank}: A rank support structure for the \texttt{ACompressed} bit vector.
    \item \texttt{sdsl::rrr\_vector<>::select\_1\_type ACompressedSelect}: A select support structure for the \texttt{ACompressed} bit vector.
    \item \texttt{std::unordered\_map<T, unsigned int> alphabetMap}: An hash map that maps each label in the alphabet to a unique integer.
    \item \texttt{unsigned int cardSigma}: The cardinality of the alphabet $\Sigma$.
    \item \texttt{unsigned int cardSigmaN}: The cardinality of the $\Sigma_N$ alphabet. Where $\Sigma_N$ is the set of labels that appear in the internal nodes of the labeled tree.
    \item \texttt{unsigned int maxNumDigits}: The maximum number of digits that has the integer code associated to the greater label in the alphabet (needed to sort the labels in the alphabet).
\end{itemize}

The overall space complexity of the XBWT class can be derived from the space complexity of the compressed data structures used in the class. 

\section{Construction of the XBWT}
The construction of the XBWT is done by the constructor of the XBWT class. The constructor takes as input a generic labeled tree and constructs the compressed indexing scheme using the linear pathSort (also the naive construction method can be used by passing the boolean flag \texttt{usePathSort = false}). The construction process is divided into the following steps:

\begin{enumerate}
    \item \textbf{Alphabet Encoding}: The first step is to encode the labels of the alphabet as integers. The labels are sorted in lexicographical order and assigned a unique integer code starting from 1 to $|\Sigma|$. Two hash maps are used to map each label to a unique integer and vice versa. 
    \item \textbf{Construct \texttt{intNodes} array}: The next step is to construct the \texttt{intNodes} array as described in the previous chapters. \texttt{intNodes} is an array of triplets of length $t$ in which node is represented as a triplet containing the node's label, its level, and the index of its parent node in the array (from 1 to t, root has parent 0). The nodes are inserted in preorder traversal of the labeled tree.
    \item \textbf{Sort \texttt{intNodes} array:} Call the \texttt{pathSort} or \texttt{upwardStableSortConstruction} (naive method) method to get the sorted array of nodes \texttt{intNodes}.
    \item \textbf{Construct $S_{\text{last}}$ array}: Construct the $S_{\text{last}}$ array by iterating over the sorted \texttt{intNodes} array.
    \item \textbf{Construct $S_{\alpha}$ array}: Construct the $S_{\alpha}$ array by iterating over the sorted \texttt{intNodes} array, along with the additional bit array to distinguish between internal and leaf nodes.
    \item \textbf{Construct $A$ array}: Construct the $A$ array by iterating over the sorted \texttt{intNodes} array.
    \item \textbf{Construct rank and select support structures}: Construct the rank and select support structures for the compressed bit vectors.
\end{enumerate}

\section{Navigational Operations}
The XBWT class provides several navigational operations to traverse the labeled tree and retrieve information about the nodes. The navigational operations implemented are:

\begin{itemize}
    \item \texttt{getChildren(unsigned int i)}: This method returns a pair of integers representing the indices of the leftmost and rightmost children of the node at index \texttt{i}.
    \item \texttt{getRankedChild(unsigned int i, unsigned int k)}: This method returns the index of the \texttt{k}-th child of the node at index \texttt{i}.
    \item \texttt{getCharRankedChild(unsigned int i, T label, unsigned int k) const}: This method returns the index of the \texttt{k}-th child of the node at index \texttt{i} with the specified label.
    \item \texttt{getDegree(unsigned int i)}: This method returns the degree (number of children) of the node at index \texttt{i}.
    \item \texttt{getCharDegree(unsigned int i, T label)}: This method returns the number of children of the node at index \texttt{i} with the specified label.
    \item \texttt{getParent(unsigned int i)}: This method returns the index of the parent of the node at index \texttt{i}.
    \item \texttt{getSubtree(unsigned int i, unsigned int order = 0)}: This method returns a vector containing the labels of the nodes in the subtree rooted at index \texttt{i}. The \texttt{order} parameter specifies the traversal order (e.g., preorder, post-order).
\end{itemize}

All the methods refer to the index of the nodes in $S_{\text{last}}$ and $S_{\alpha}$ arrays. 

\section{Search Operations}
The XBWT class provides search operation \texttt{subPathSearch(const std::vector<T> \&path)} that searches for a subpath in the XBWT structure. It uses the compressed vectors to determine the range of positions corresponding to the nodes whose upward path is prefixed by a given vector reversed.
