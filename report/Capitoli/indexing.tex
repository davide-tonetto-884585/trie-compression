\chapter{Indexing Finite State Automata} \label{chp:indexing}
\section{Introduction and Motivations}
In previous chapters, we addressed the challenges related to identifying and optimizing the representation of repetitive structures within a tree. We demonstrated how a tree can be effectively modeled as a DAWG and how applying DFA minimization algorithms, particularly Revuz's algorithm, enables the identification of node equivalence classes representing identical substructures (\cref{chp:hopcroft}). Subsequently, we proposed an innovative approach to partition these nodes into $p$ chains, formulating this problem as a MWPBM problem, and to optimize compression by collapsing consecutive equivalent nodes within each chain (\cref{chp:min_weight_perfect_bipartite_matching,def:collapsing}).

The next logical and crucial step for the completeness of our compression scheme is the ability to query the compressed structure efficiently. A compact representation is only partially useful if it doesn't allow for quick access and meaningful search operations.

The objective of this chapter is therefore to apply the finite state automata index based on co-lexicographical orders introduced by Cotumaccio et al. \cite{cotumaccio2023co} to the chains generated by our tree compression process.

\textit{Disclaimer: In this chapter, we will not delve into the technical details and inner workings of the finite state automata index, as this falls outside the scope of this thesis. Instead, we will focus on how this index can be effectively applied to our compressed tree structure.}

\section{Theoretical Background}
Before diving into the details of the finite state automata index, it is important to introduce some concepts that will be used in the following sections.

Lets start by defining the theory of co-lexicographic order. The notion of co-lexicographic order is essential for the finite state automata index, as it allows us to define an ordering of the states of an automaton. 
\begin{definition} [Co-lexicographic Order]
    The co-lexicographic order $\preceq$ is defined on the set of words in $\Sigma^*$. Given two strings $\alpha, \beta \in \Sigma^*$, we say that $\alpha \preceq \beta$ if and only if either:
    \begin{itemize}[leftmargin=25pt]
        \item $\alpha$ is a suffix of $\beta$, or
        \item there exist strings $\alpha', \beta', \gamma \in \Sigma^*$ and symbols $a, b \in \Sigma$, such that $\alpha = \alpha'a\gamma$, $\beta = \beta'b\gamma$, and $a \prec b$.
    \end{itemize}
\end{definition}
Co-lexicographic order can be extended to the set of states of an automaton. The idea of co-lexicographic order on the states of an automaton was first introduced with the notion of Wheeler graphs by Gagie et al.~\cite{gagie2017wheeler} and was later generalized to arbitrary finite automata by Cotumaccio and Prezza~\cite{cotumaccio2021indexing}, where a partial order replaces the total order. The definition of co-lexicographic order on an automaton is as follows:

\begin{definition} \label{def:colex_order_on_automaton}
    Let $N = (Q, \Sigma, \delta, q_0, F)$ be an NFA. A co-lexicographic order on $N$ is a partial order $\leq$ on $Q$ that satisfies the following two axioms:
    \begin{enumerate}[leftmargin=25pt]
        \item For every $u, v \in Q$, if $u < v$, then $\max\lambda(u) < \min\lambda(v)$
        \item For every $a \in \Sigma$ and $u, v, u', v' \in Q$, if $u \in \delta(u', a)$, $v \in \delta(v', a)$ and $u < v$, then $u' \leq v'$
    \end{enumerate}
\end{definition}
Where $\lambda(q)$ denotes the set of labels of transitions entering state $q$, and $\min\lambda(q)$ and $\max\lambda(q)$ represent the minimum and maximum element of the set, respectively.

Now, let's define the formal concept of partial order and the width of a partial order. 
\begin{definition}[Partial Order]
    A partial order is a binary relation $\leq$ over a set $S$ that is reflexive, antisymmetric, and transitive. That is, for all $a, b, c \in S$:
    \begin{itemize}[leftmargin=25pt]
        \item $a \leq a$ (reflexivity)
        \item if $a \leq b$ and $b \leq a$, then $a = b$ (antisymmetry)
        \item if $a \leq b$ and $b \leq c$, then $a \leq c$ (transitivity)
    \end{itemize}
\end{definition}

\begin{definition}[Antichain]
    An antichain of a partially ordered set $(S, \leq)$ is a subset of $S$ where any two distinct elements are incomparable. That is, for any two distinct elements $a, b$ in the antichain, neither $a \leq b$ nor $b \leq a$ holds.
\end{definition}

\begin{definition}[Width]
    The width of a partially ordered set is the size of the largest possible antichain.
\end{definition}
In other words, the width of a partially ordered set $(S, \leq)$ can be equivalently defined as the minimum number of chains needed to partition $S$, where each chain is a totally ordered subset of $S$ under the relation $\leq$.

\section{Finite State Automata Index}
The finite state automaton index is an evolution of the concept of co-lexicographical ordering of automaton states to build an efficient index. This index has proven effective for partially ordered graphs with reduced width \cite{cotumaccio2023co}.

The finite state automata index primarily supports locate, count, and membership queries. In the context of our application to chains, these queries are formally defined as:

\begin{enumerate}
    \item \textbf{Locate on chain}: Returns the set of all states reachable from a labeled path $\alpha$. Each state $v$ is mapped to a pair $(\phi(v), \rho(v))$, where $\phi(v)$ is the index of the chain to which $v$ belongs and $\rho(v)$ is the position of $v$ within that chain.
    \item \textbf{Count}: Returns the number of states reachable from a labeled path $\alpha$, i.e., the cardinality of the set returned by locate on chain of $\alpha$.
    \item \textbf{Membership}: Returns True if and only if the string $\alpha$ belongs to the language accepted by the automaton.
\end{enumerate}

The adoption of this index will allow us to extend the capabilities of our compression scheme well beyond simple space reduction. We will be able to execute complex queries directly on the compressed tree representation, treating the chains of equivalence classes as automaton states. It is crucial to note that the efficiency of this index is inherently dependent on the width $p$ of the automaton, a parameter that, in our context, directly corresponds to the number of chains into which we have divided the tree nodes.

Follows a brief explanation of the functionalities of the finite state automata index.

\subsection{Co-lexicographical Ordering of States}
The core concept behind the index is the \textbf{co-lexicographical ordering} of the automaton's states. For an automaton, this means ordering states based on the co-lexicographical order of the strings (paths) that reach them from the initial state. If an automaton fully satisfies this order and is Wheeler \cite{gagie2017wheeler}, the ordering is total; otherwise, a partial order is obtained. The closeness of this partial order to a total order is measured by the \textbf{co-lexicographical width ($p$)}, which is crucial for the index's performance.

\subsection{Automaton Burrows-Wheeler Transform (aBWT)}
The index is built from the \textbf{aBWT} \cite{cotumaccio2023co}, a generalization of the classic Burrows-Wheeler Transform (BWT) for strings. The aBWT is a compact representation of the NFA derived from the co-lexicographical ordering of its states and a partition of the states into chains.

The construction of the aBWT involves ordering the automaton's transitions. This ordering is stable and is primarily based on the transition's starting state. For transitions originating from the same state, the ordering is by label (symbol) and then by destination state.

The aBWT consists of five main sequences:
\begin{itemize}
    \item \textbf{CHAIN}: A bit vector indicating the start of each chain.
    \item \textbf{FINAL}: A bit vector indicating whether a state is a final state.
    \item \textbf{IN\_DEG} and \textbf{OUT\_DEG}: Bit vectors encoding the in-degree and out-degree of each state, respectively.
    \item \textbf{OUT}: A sequence storing transition labels and the indices of destination chains. This sequence is crucial for navigation.
\end{itemize}
An additional structure, \textbf{IN'}, identifies intervals of incoming transitions with the same label or belonging to the same chain.

\subsection{Query Process: Forward Search} 
All queries supported by the index are resolved using an iterative mechanism called \textbf{Forward Search}. This process calculates two key sets for each prefix ($\alpha'$) of the query string $\alpha$: $S(\alpha')$ (states reachable by strings co-lexicographically smaller than $\alpha'$) and $R(\alpha')$ (states reachable by strings co-lexicographically smaller than $\alpha'$ or having $\alpha'$ as a suffix). The set $T(\alpha')$ (states reachable by $\alpha'$) is obtained from the difference between $R(\alpha')$ and $S(\alpha')$.

The search proceeds character by character, iteratively updating the intervals that define $S(\alpha)$ and $R(\alpha)$ for each chain. This involves efficient operations on the indices based on the bit vectors.

\subsection{Complexity and Trade-offs} 
The efficiency of the index, both in terms of query execution time and space consumption, is heavily influenced by the width ($p$) of the automaton. The time complexity of the queries is $O(m \cdot p^2 \log(p\sigma))$, where $m$ is the length of the query, and $\sigma$ is the alphabet size. This quadratic relationship with $p$ implies that the index is most efficient for an automaton with a relatively small $p$. For small values of $p$, the index can be even more compact than the direct representation of the automaton, as proved in \cite{maso2023indexing}.

\section{Application to Tree Compression}
The chains used in our compression scheme are obtained as a solution to the \textsc{Chain-Division} problem (\cref{def:problem_def}), which decompose the tree into $p$ disjoint chains ($p$ will be exactly the width of our indexed automaton). What makes this decomposition particularly suitable for our indexing approach is that these chains are inherently ordered co-lexicographically. This natural ordering is achieved through the \texttt{PathSort} algorithm (\cref{alg:pathSort}), which orders nodes based on their upward paths $\pi$, leading to a co-lexicographical ordering of the chains as proved by \cref{lemma:greater_nodes} and by definition of chain for the \textsc{Chain-Division} problem (\cref{def:chains}).

% Added paragraph to connect to collapsed chains (previous chapter)
In the previous chapter, we further reduce space by collapsing consecutive equivalent nodes within each chain, obtaining an NFA $N$ whose states are the collapsed blocks (\cref{def:collapsing}). This transformation is language-preserving (\cref{lemma:collapsing_equivalence}), so indexing $N$ recognizes exactly the same set of root-to-leaf strings as the original tree DAWG. Throughout this chapter, the indexing scheme is applied to these collapsed chains (i.e., to the NFA $N$), which retain the co-lexicographic order induced by \texttt{PathSort}.

Specifically, when the \texttt{PathSort} algorithm processes the tree, it considers the complete path from each node's parent to the root, denoted as $\pi$. This upward traversal naturally induces a co-lexicographical ordering on the chains, as nodes sharing longer common prefixes in their upward paths are grouped. This property is essential for the indexing structure, as it allows for maintaining efficient access patterns while preserving the structural relationships within the tree.

More formally, the co-lexicographical ordering induced by \texttt{PathSort} satisfies two key axioms of \cref{def:colex_order_on_automaton} that generalize the notion of prefix sorting to our tree structure:

\begin{enumerate}
    \item For any two nodes $u,v$ in the tree, if $u < v$ in the ordering, then the maximum label in the path to $u$ is less than the minimum label in the path to $v$ (preserving label ordering)
    \item For any label $a$ and nodes $u,v,u',v'$, if $u$ is reachable from $u'$ via label $a$, $v$ is reachable from $v'$ via label $a$, and $u < v$, then $u' \leq v'$ (preserving parent-child relationships)
\end{enumerate}

These axioms ensure that our chain decomposition maintains proper\\ co-lexicographical properties required by the indexing structure, while naturally extending from simple path cases to our more complex tree structure.

